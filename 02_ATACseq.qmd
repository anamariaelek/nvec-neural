---
title: "02. ATACseq"
format:
  html:
    toc: true
    toc-location: left
editor: visual
---

## Setup

Load packages

```{r warning=FALSE, message=FALSE, results = FALSE}
library(data.table)
library(stringr)
library(ggplot2)
theme_py <- theme_light() + theme(
  panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(),
  panel.border = element_rect(colour = "black", fill = NA),
  text = element_text(size=20),
  strip.placement = "outside", 
  strip.text = element_text(size=20, color="black"),
  strip.background = element_rect(fill="white")
)
theme_set(theme_py)
library(patchwork)
library(ggrepel)
library(ComplexHeatmap)
library(DESeq2)
library(consensusSeekeR)
library(BSgenome.jaNemVect1.1.DToL.Assembly)
library(GenomicRanges)
library(parallel)
```

Directories

```{r}
dat_dir <- "ATACSEQ/nucleosome_free_regions/"
pks_dir <- file.path(dat_dir, "macs2_peaks")
cns_dir <- file.path(dat_dir, "consensus_peaks")
res_dir <- file.path(dat_dir, "results")
for (newdir in c(cns_dir, res_dir))
  dir.create(newdir, showWarnings = FALSE)
```

## Differntial peak analysis

Find consensus set of peaks

```{r eval=FALSE}
require(consensusSeekeR)
require(BSgenome.jaNemVect1.1.DToL.Assembly)
require(parallel)

# load peaks
pks_files <- list.files(pks_dir, pattern="narrowPeak", recursive=FALSE, full.names=TRUE)
names(pks_files) <- str_remove(basename(pks_files), ".mLb.clN.ncfree_peaks.narrowPeak")
nP_list <- lapply(names(pks_files), function(x) {
    nP <- readNarrowPeakFile(pks_files[x], extractRegions = TRUE, extractPeaks = TRUE)
    names(nP$narrowPeak) <- rep(x, length(nP$narrowPeak))
    names(nP$peak) <- rep(x, length(nP$peak))
    nP
})
regions <- GenomicRanges::GRangesList(lapply(nP_list, function(x) x$narrowPeak))
peaks <- GenomicRanges::GRangesList(lapply(nP_list, function(x) x$peak))
names(regions) <- names(pks_files)
names(peaks) <- names(pks_files)

# get consensus
chrList <- Seqinfo(
  seqnames = seqnames(BSgenome.jaNemVect1.1.DToL.Assembly),
  seqlengths = seqlengths(BSgenome.jaNemVect1.1.DToL.Assembly),
  isCircular = c(rep(FALSE, length(seqnames(BSgenome.jaNemVect1.1.DToL.Assembly))-1), TRUE),
  genome = "jaNemVect1.1"
)
message(Sys.time(), " Started calculating consensus")
results <- findConsensusPeakRegions(
    narrowPeaks = unlist(regions),
    peaks = unlist(peaks),
    chrInfo = chrList,
    extendingSize = 100,
    expandToFitPeakRegion = TRUE,
    shrinkToFitPeakRegion = TRUE,
    minNbrExp = 3,
    nbrThreads = detectCores()-1
)
message(Sys.time(), " Done calculating consensus")
saveRDS(results, file.path(cns_dir,"consensusSeekeR-results.RDS"))

# resize peaks
pks_cns <- results$consensusRanges
pks_mid <- start(pks_cns) + (end(pks_cns)-start(pks_cns))/2
ranges(pks_cns) <- IRanges(pks_mid,width=0)
pks_scl <- promoters(pks_cns, upstream=125, downstream=125)

# trim out-of-bound peaks
seqlengths(pks_scl) <- seqlengths(BSgenome.jaNemVect1.1.DToL.Assembly)[names(seqlengths(pks_scl))]
pks_scl <- trim(pks_scl)

# save bed file
pks_bed <- as.data.table(pks_scl)
pks_bed[,name:=paste0("peak",1:.N)]
pks_bed[,width:=NULL][,score:="."]
setcolorder(pks_bed, c("seqnames","start","end","name","score","strand"))
fwrite(pks_bed, file.path(cns_dir,"consensusSeekeR-peaks.bed"), sep="\t", col.names=FALSE)
```

Get scores for consensus peaks in all samples.

```{r include=FALSE, eval=FALSE}
# load consensus peaks
pks_bed <- fread(file.path(cns_dir,"consensusSeekeR-peaks.bed"))
setnames(pks_bed, c("seqnames", "start", "end", "name", "score", "strand"))
pks_grn <- makeGRangesFromDataFrame(pks_bed, keep.extra.columns = TRUE)

# get counts in consensus peaks
bws_files <- list.files(file.path(dat_dir, "bigwig"), pattern = ".bigwig", full.names = TRUE)
bws_names <- str_remove(basename(bws_files),".mLb.clN.ncfree.bigwig")
names(bws_files) <- bws_names
bws_signal <- rbindlist(lapply(bws_names, function(smp){
  as.data.table(import(bws_files[smp]))[,sample:=smp][]
}))

# overlap signal with consensus peaks
pks_list <- lapply(bws_names, function(smp) {
  bw_dt <- bws_signal[sample==smp]
  bw_gr <- makeGRangesFromDataFrame(bw_dt, keep.extra.columns = TRUE)
  # ovl
  ovl <- findOverlaps(query = bw_gr, subject = pks_grn)
  ps_dt <- as.data.table(pks_grn[subjectHits(ovl)])
  scs <- mcols(bw_gr[queryHits(ovl)])$score
  ps_dt[,score:=scs]
  # non ovl
  if (any(!pks_grn$name %in% ps_dt$name)) {
    message("Adding missing peks for ", smp)
    ps_dt <- rbindlist(list(
      ps_dt,
      as.data.table(pks_grn)[!name %in% ps_dt$name][,score:=0]
    ), use.names = TRUE)
  }
  ps_dt[,sample:=smp][]
})
pks_dt <- rbindlist(pks_list)

# keep max signal in each peak
pks_dt[,score:=as.numeric(score)]
pkt_dt <- pks_dt[order(name,-score)][,.SD[1],.(name,sample)]
pkt_dt[,seqnames:=factor(seqnames, levels=levels(seqnames(pks_grn)))]
setorder(pkt_dt, seqnames, start, end)

# save bed file
pkt_dt[,width:=NULL]
setcolorder(pkt_dt, c("seqnames", "start", "end", "name", "score", "strand", "sample"))
fwrite(pkt_dt, file.path(cns_dir,"consensusSeekeR-peaks-samples.bed"), sep="\t", col.names=FALSE)
```
```{bash eval=FALSE, eval=FALSE}
nth=12
res="ATACSEQ/nucleosome_free_regions/consensus_peaks/consensusSeekeR-peaks-counts.tsv"
bed="ATACSEQ/nucleosome_free_regions/consensus_peaks/consensusSeekeR-peaks.bed"
bam=$( ls ATACSEQ/nucleosome_free_regions/bam/*bam )

cols=$( echo -e seqnames start end name score strand | column -t )
for b in $bam
do 
  name=$( basename $b)
  cols=$( echo -e ${cols} ${name} | column -t )
done

echo -e ${cols} > ${res%%tsv}txt
bedtools multicov -bams ${bam} -bed ${bed} > ${res}
```

Data for differential peaks analysis

```{r}
# load counts in peaks
pks_ct <- fread(file.path(cns_dir, "consensusSeekeR-peaks-counts.tsv"), header=FALSE)
colnames <- readLines(file.path(cns_dir, "consensusSeekeR-peaks-counts.txt"), n=1)
colnames <- str_remove_all(colnames, ".mLb.clN.ncfree.sorted.bam")
colnames <- str_split(colnames, " ")[[1]]
colnames(pks_ct) <- colnames

# column data
condition_cols <- c("positive"="blue","negative"="red") 
line_cols = c("Elav" = "#ff7f00", "Fox" = "#984ea3", "Ncol" = "#4daf4a")

col_dt <- data.table(sample=colnames(pks_ct)[7:28])
col_dt[,reporterline:=str_extract(sample,"Elav|Fox|Ncol")]
col_dt[,reporterline:=factor(reporterline, levels=c("Elav","Fox","Ncol"))]
col_dt[,condition:=str_extract(sample,"pos|neg")]
col_dt[,condition:=str_replace_all(condition,c("pos"="positive","neg"="negative"))]
col_dt[,condition:=factor(condition, levels = c("positive","negative"))]

col_df <- copy(col_dt)
class(col_df) <- "data.frame"
rownames(col_df) <- col_df$sample

# counts matrix
pks_mt <- as.matrix(pks_ct[,-c(1:6)])
rownames(pks_mt) <- pks_ct$name
pks_mt <- pks_mt[,rownames(col_df)]
```

DESeq2

```{r eval=FALSE}
require(DESeq2)
dds <- DESeqDataSetFromMatrix(
  countData = pks_mt,
  colData = col_df,
  design = ~ condition + reporterline + condition:reporterline
)
dds <- DESeq(dds)
saveRDS(dds, file.path(res_dir, "dds.rds"))

# DE results
res <- results(dds)
res <- results(dds, contrast=c("condition","positive","negative"))
resLFC <- lfcShrink(dds, coef="condition_negative_vs_positive", type="apeglm")

```

## Marker peaks

Use normalized log-transformed expression data

```{r}
# load DESeq2 results
dds <- readRDS(file.path(res_dir, "dds.rds"))

# transformation
vsd <- vst(dds, blind=FALSE)
# rld <- rlog(dds, blind=FALSE)
norm_mt <- vsd@assays@data[[1]]
```

Inspect peaks normalized accessibility distribution

```{r fig.width=8, fig.height=6, warning=FALSE, message=FALSE}
# normalized accessibility distribution
norm_dt <- as.data.table(norm_mt, keep.rownames = "peak")
norm_dt <- melt.data.table(norm_dt, id.vars = "peak", variable.name = "sample", value.name = "norm_counts")
norm_dt <- merge.data.table(norm_dt, col_dt, by="sample")
setorder(norm_dt, peak,condition, reporterline)
norm_dt[,sample:=factor(sample, levels = unique(norm_dt$sample))]

gp_acc <- ggplot(norm_dt, aes(sample, norm_counts, fill=reporterline)) +
  geom_violin(scale = "width", alpha = 0.8, color = "black") +
  geom_boxplot(width = 0.5, outlier.shape = NA, alpha = 0.8, color = "black") + 
  scale_fill_manual(values = line_cols, limits = force) +
  scale_y_continuous(expand = expansion(mult = c(0,0.01))) +
  labs(x="samples", y="normalized\npeaks accessibility") +
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
    legend.title = element_blank(), legend.position = "none"
  )

var_dt <- norm_dt[,.(var=var(norm_counts)),.(peak)]
gp_var <- ggplot(var_dt, aes(log10(var))) + 
  geom_density() +
  scale_y_continuous(expand = expansion(mult = c(0,0.01))) +
  labs(x = "log10(peak accessibility variance)")

gp_acc / gp_var + plot_layout(heights = c(2,1))
```

Identify marker peaks

```{r}
# peak markers by normalized accessibility
peaks_high <- names(which(apply(norm_mt, 1, function(x) sort(x,decreasing=TRUE)[2])>2))
peaks_vari <- names(which(apply(norm_mt, 1, function(x) var(x)>0.5)))
peaks_marks <- intersect(peaks_high, peaks_vari)
```

```{r include=FALSE, eval=FALSE}
# peak markers by normalized accessibility + significant kruskall wallis
factor <- paste0(col_dt$condition, col_dt$reporterline)
kw_pvals <- apply(norm_mt, 1, function(x) kruskal.test(x~factor)$p.value)
kw_qvals <- p.adjust(kw_pvals, method="BH")
kw_peaks <- names(which(kw_qvals<0.05))
peaks_high <- names(which(apply(norm_mt, 1, function(x) sort(x,decreasing=TRUE)[2])>2))
peaks_marks <- intersect(peaks_high, kw_peaks)
```

Cluster peaks

```{r include=FALSE, eval=FALSE}
# hclust genes
cor_peaks <- cor(t(norm_mt[peaks_marks,]))
hclust_peaks <- hclust(as.dist(1-cor(cor_peaks)),method="ward.D2")
peaks_order <- rownames(cor_peaks)[hclust_peaks$order]
```

```{r}
set.seed(1950)

# determine k for kmeans
ks <- 1:20
tot_withinss <- sapply(ks,  function(k) {
  cl <- kmeans(norm_mt[peaks_marks,], k)
  cl$tot.withinss
})
elbow_dt <- data.table(k = ks, tot_withinss = tot_withinss)
elbow_gp <- ggplot(elbow_dt, aes(x = k, y = tot_withinss)) +
  geom_line() + geom_point()+
  scale_x_continuous(breaks = ks)

# kmeans
set.seed(1950)
k <- 7
cl <- kmeans(norm_mt[peaks_marks,], k)
peaks_order <- tapply(names(cl$cluster), cl$cluster, function(gs) {
  cor_peaks <- cor(t(norm_mt[gs,]))
  hclust_peaks <- hclust(as.dist(1-cor(cor_peaks)),method="ward.D2")
  rownames(cor_peaks)[hclust_peaks$order]
})
cluster_order <- hclust(dist(cor(cor(t(cl$centers)))),method="ward.D2")$order
peaks_order <- unlist(peaks_order[rev(cluster_order)])
```

Heatmap of markers

```{r fig.height=10, fig.width=8, warning=FALSE, message=FALSE}
# matrix to plot
samples_order <- col_dt[order(condition,reporterline)]$sample
plot_mt <- norm_mt[peaks_order,samples_order]
plot_max <- quantile(abs(range(plot_mt)), 0.75)
plot_min <- min(abs(range(plot_mt)))
plot_mt <- pmin(plot_mt, plot_max)
col_vec <- c("white","#d6e72e","#6fb600","#003f4d")
col_fun <- circlize::colorRamp2(seq(plot_min, plot_max, length.out = length(col_vec)), col_vec)
col_ann <- HeatmapAnnotation(
    which = "column", border = TRUE,
    "reporterline" = as.character(col_dt[match(colnames(plot_mt),sample)]$reporterline),
    "condition" = as.character(col_dt[match(colnames(plot_mt),sample)]$condition), 
    col = list("reporterline" = line_cols, "condition" = condition_cols)
)
hm <- Heatmap(
  plot_mt, name = "normalized\naccessibility", border = TRUE, 
  col = col_fun,
  cluster_rows = FALSE, cluster_columns = FALSE,
  show_row_names = FALSE, show_column_names = TRUE,
  row_title = "peaks",
  top_annotation = col_ann
)
hm
```

## PCA

PCA on all samples.

```{r fig.width=8, fig.height=10, warning=FALSE}
set.seed(1950)
pca_res <- prcomp(t(norm_mt), center = TRUE)

# variance explained
pca_var <- data.table(pct_var = round(((pca_res$sdev) ^ 2 / sum((pca_res$sdev) ^ 2)* 100), 2))
pca_var[,pct_cum:=cumsum(pct_var)]
pca_var[,PC:=factor(1:.N)]
gp_var <- ggplot(pca_var, aes(PC, pct_var)) + 
  geom_bar(stat = "identity") +
  geom_line(aes(y = pct_cum, group = 1)) + 
  geom_point(aes(y = pct_cum)) +
  scale_y_continuous(expand = expansion(0.01,0)) +
  labs(y = "% of variance\nexplained", x = "PC") +
  theme(panel.grid.major.y = element_line(size = 0.5))

pca_dt <- as.data.table(pca_res$x, keep.rownames = "sample")
pca_dt <- merge.data.table(col_dt, pca_dt, by="sample", sort=FALSE)
gp_bip <- ggplot(pca_dt, aes(PC1, PC2, fill=reporterline, shape=condition)) + 
  geom_point(size=5) +
  scale_fill_manual(values = line_cols) +
  scale_shape_manual(values = c("positive" = 21, "negative" = 24)) +
  geom_text_repel(aes(label = sample))

gp_var / gp_bip 
```

PCA per cell line

```{r fig.height=8, fig.width=7}
set.seed(1950)

gp_l <- lapply(names(line_cols), function(cl) {
  
  pca_res <- prcomp(t(norm_mt[,grep(cl,colnames(norm_mt))]), center = TRUE)
  
  # variance explained
  pca_var <- data.table(pct_var = round(((pca_res$sdev) ^ 2 / sum((pca_res$sdev) ^ 2)* 100), 2))
  pca_var <- pca_var[-nrow(pca_var)]
  pca_var[,pct_cum:=cumsum(pct_var)]
  pca_var[,PC:=factor(1:.N-1)]
  gp_var <- ggplot(pca_var, aes(PC, pct_var)) + 
    geom_bar(stat = "identity") +
    geom_line(aes(y = pct_cum, group = 1)) + 
    geom_point(aes(y = pct_cum)) +
    scale_y_continuous(expand = expansion(0.01,0)) +
    labs(y = "% of variance\nexplained", x = "PC") +
    theme(panel.grid.major.y = element_line(size = 0.5))
  
  # pca plot
  pca_dt <- as.data.table(pca_res$x, keep.rownames = "sample")
  pca_dt <- merge.data.table(col_dt, pca_dt, by="sample", sort=FALSE)
  gp_bip <- ggplot(pca_dt, aes(PC1, PC2, fill=condition, shape=condition)) + 
    geom_point(size=5) +
    scale_shape_manual(values = c("positive" = 21, "negative" = 24)) +
    scale_fill_manual(values = condition_cols) +
    geom_text_repel(aes(label = sample))
  
  gp_var / gp_bip 

})
gp_l
```
