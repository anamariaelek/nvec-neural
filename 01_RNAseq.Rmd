---
title: "RNAseq"
output:
  html_document:
    self_contained: true
    toc: true
    toc_float: true
    toc-location: left
editor: visual
---

## Setup

Load packages

```{r warning=FALSE, message=FALSE, results = FALSE}
library(data.table)
library(stringr)
library(ggplot2)
theme_py <- theme_light() + theme(
  panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(),
  panel.border = element_rect(colour = "black", fill = NA),
  text = element_text(size=20),
  strip.placement = "outside", 
  strip.text = element_text(size=20, color="black"),
  strip.background = element_rect(fill="white")
)
theme_set(theme_py)
library(patchwork)
library(ggrepel)
library(ComplexHeatmap)
library(DESeq2)
library(caret)
library(pROC)
```

Directories and inputs

```{r}
dat_dir <- "RNASEQ_QUANTIFICATION"
res_dir <- file.path(dat_dir, "results")
fig_dir <- file.path(dat_dir, "plots")
for (newdir in c(res_dir, fig_dir))
  dir.create(newdir, showWarnings = FALSE)
```

## Gene counts

Load expression data

```{r}
# column data
des_fn <- file.path(dat_dir, "design_table.tsv")
des_dt <- fread(des_fn)
setnames(des_dt, "reporter_line","reporterline") # DESeq factors have problems with _
col_dt <- des_dt[,.(sample,reporterline,condition)]
col_dt[,reporterline:=factor(reporterline, levels=c("Elav","Fox","Ncol"))]
col_dt[,condition:=factor(condition, levels = c("negative","positive"))]
setorder(col_dt, reporterline, condition)

condition_cols <- c("positive"="blue","negative"="red") 
line_cols = c("Elav" = "#ff7f00", "Fox" = "#984ea3", "Ncol" = "#4daf4a")

col_df <- copy(col_dt)
class(col_df) <- "data.frame"
rownames(col_df) <- col_df$sample

# count matrix
con_fn <- file.path(dat_dir, "raw_counts_rnaseq.tsv")
con_df <- read.table(con_fn, header = TRUE)
con_mt <- as.matrix(con_df[,rownames(col_df)])
rownames(con_mt) <- con_df$transcript
```

```{r echo=FALSE, include=FALSE, fig.width=7, fig.height=5}
con_dt <- as.data.table(con_mt, keep.rownames="gene")
con_dt <- melt.data.table(con_dt, id.vars="gene", variable.name="sample", value.name="expr")
con_dt <- merge.data.table(con_dt, col_dt, by="sample", all.x=TRUE, sort=FALSE)
ggplot(con_dt, aes(log10(expr+1))) +
  geom_density() +
  facet_grid(condition~reporterline) 
```

Data for differential expression analysis

```{r eval=FALSE}
require(DESeq2)
dds <- DESeqDataSetFromMatrix(
  countData = con_mt,
  colData = col_df,
  design = ~ condition + reporterline + condition:reporterline
)
saveRDS(dds, file.path(res_dir, "dds.rds"))
```

Inspect genes expression distribution

```{r fig.width=8, fig.height=6, warning=FALSE, message=FALSE}
# normalized accessibility distribution
con_dt <- as.data.table(con_mt, keep.rownames = "gene")
con_dt <- melt.data.table(con_dt, id.vars = "gene", variable.name = "sample", value.name = "norm_counts")
con_dt <- merge.data.table(con_dt, col_dt, by="sample")
setorder(con_dt, gene, condition, reporterline)
con_dt[,sample:=factor(sample, levels = unique(con_dt$sample))]

gp_exp <- ggplot(con_dt, aes(sample, log10(norm_counts), fill=reporterline)) +
  geom_violin(scale = "width", alpha = 0.8, color = "black") +
  geom_boxplot(width = 0.5, outlier.shape = NA, alpha = 0.8, color = "black") + 
  scale_fill_manual(values = line_cols, limits = force) +
  scale_y_continuous(expand = expansion(mult = c(0,0.01))) +
  labs(x="samples", y="gene counts") +
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
    legend.title = element_blank(), legend.position = "none"
  )

var_dt <- con_dt[,.(var=var(norm_counts)),.(gene)]
gp_var <- ggplot(var_dt, aes(log10(var))) + 
  geom_density() +
  scale_x_continuous(limits=c(-4,NA)) +
  scale_y_continuous(expand = expansion(mult = c(0,0.01))) +
  labs(x = "log10(expression variance)")

gp_pch <- gp_exp / gp_var + plot_layout(heights = c(2,1))
gp_pch
```
```{r include=FALSE, eval=TRUE}
pdf(file.path(fig_dir, "genes_var.pdf"), width=8, height=6)
gp_pch
dev.off()
```

Use normalized log-transformed expression data

```{r}
# normalize samples
dds <- readRDS(file.path(res_dir, "dds.rds"))
dds <- estimateSizeFactors(dds)
norm_mt <- counts(dds, normalized=TRUE)
# row normalize to bring genes to same range
norm_mt <- (norm_mt+10)/apply(norm_mt+10,1,median) 
norm_mt <- log2(norm_mt)
# save
write.table(norm_mt, file.path(res_dir,"norm_expression.tsv"), sep="\t", row.names = TRUE, quote = FALSE)
```

## PCA

PCA on all samples

```{r fig.width=8, fig.height=10, warning=FALSE}
set.seed(1950)
pca_res <- prcomp(t(norm_mt), center = TRUE)

# variance explained
pca_var <- data.table(pct_var = round(((pca_res$sdev) ^ 2 / sum((pca_res$sdev) ^ 2)* 100), 2))
pca_var[,pct_cum:=cumsum(pct_var)]
pca_var[,PC:=factor(1:.N)]
gp_var <- ggplot(pca_var, aes(PC, pct_var)) + 
  geom_bar(stat = "identity") +
  geom_line(aes(y = pct_cum, group = 1)) + 
  geom_point(aes(y = pct_cum)) +
  scale_y_continuous(expand = expansion(0.01,0)) +
  labs(y = "% of variance\nexplained", x = "PC") +
  theme(panel.grid.major.y = element_line(size = 0.5))

pca_dt <- as.data.table(pca_res$x, keep.rownames = "sample")
pca_dt <- merge.data.table(col_dt, pca_dt, by="sample", sort=FALSE)

gp_bip <- ggplot(pca_dt, aes(PC1, PC2, fill=reporterline, shape=condition)) + 
  geom_point(size=5) +
  scale_fill_manual(values = line_cols) +
  scale_shape_manual(values = c("positive" = 21, "negative" = 24)) +
  guides(fill = guide_legend(override.aes=list(shape=21))) +
  geom_text_repel(aes(label = sample))

gp_var / gp_bip 
```

PCA per cell line

```{r fig.height=8, fig.width=7}
set.seed(1950)

gp_l <- lapply(names(line_cols), function(cl) {
  
  pca_res <- prcomp(t(norm_mt[,grep(cl,colnames(norm_mt))]), center = TRUE)
  
  # variance explained
  pca_var <- data.table(pct_var = round(((pca_res$sdev) ^ 2 / sum((pca_res$sdev) ^ 2)* 100), 2))
  pca_var <- pca_var[-nrow(pca_var)]
  pca_var[,pct_cum:=cumsum(pct_var)]
  pca_var[,PC:=factor(1:.N-1)]
  gp_var <- ggplot(pca_var, aes(PC, pct_var)) + 
    geom_bar(stat = "identity") +
    geom_line(aes(y = pct_cum, group = 1)) + 
    geom_point(aes(y = pct_cum)) +
    scale_y_continuous(expand = expansion(0.01,0)) +
    labs(y = "% of variance\nexplained", x = "PC") +
    theme(panel.grid.major.y = element_line(size = 0.5))
  
  # pca plot
  pca_dt <- as.data.table(pca_res$x, keep.rownames = "sample")
  pca_dt <- merge.data.table(col_dt, pca_dt, by="sample", sort=FALSE)
  gp_bip <- ggplot(pca_dt, aes(PC1, PC2, fill=condition, shape=condition)) + 
    geom_point(size=5) +
    scale_shape_manual(values = c("positive" = 21, "negative" = 24)) +
    scale_fill_manual(values = condition_cols) +
    guides(fill = guide_legend(override.aes=list(shape=21))) +
    geom_text_repel(aes(label = sample))
  
  gp_var / gp_bip 

})
gp_l
```

## Marker genes

Use normalized gene counts

```{r}
norm_mt <- read.table(file.path(res_dir,"norm_expression.tsv"), header = TRUE)
```

Identify marker genes

```{r include=FALSE, eval=FALSE}
# gene markers by normalized expression
genes_high <- names(which(apply(norm_mt, 1, function(x) sort(x,decreasing=TRUE)[2])>1.5))
genes_vari <- names(which(apply(norm_mt, 1, function(x) var(x)>0.1)))
gene_marks <- intersect(genes_high, genes_vari)
```

```{r include=TRUE, eval=TRUE}
# gene markers by high FC + significant DEseq2 LTR test 
dds <- readRDS(file.path(res_dir, "dds.rds"))
dds <- DESeq(dds, test="LRT", reduced=~1)
dds_res <- results(dds)
dds_qval <- dds_res$padj 
names(dds_qval) <- rownames(dds_res)
genes_deseq <- names(which(dds_qval<1e-2))
gene_marks <- genes_deseq
genes_high <- names(which(apply(norm_mt, 1, function(x) sort(x,decreasing = T)[2])>1.8))
gene_marks <- intersect(genes_high, genes_deseq)
```

Select number of clusters for genes

```{r fig.width=10, fig.height=6}
set.seed(1950)

# determine k for kmeans
ks <- 1:30
tot_withinss <- sapply(ks,  function(k) {
  cl <- kmeans(norm_mt[gene_marks,], k)
  cl$tot.withinss
})
elbow_dt <- data.table(k = ks, tot_withinss = tot_withinss)
elbow_gp <- ggplot(elbow_dt, aes(x = k, y = tot_withinss)) +
  geom_line() + geom_point() +
  scale_x_continuous(breaks = ks) + 
  theme(panel.grid.major = element_line(size = 0.5))
elbow_gp
```

```{r include=FALSE, eval=TRUE}
pdf(file.path(fig_dir, "kmeans_elbow.pdf"), width=8, height=6)
elbow_gp
dev.off()
```

Cluster genes

```{r}
set.seed(1950)

# kmeans
k <- 20
cl <- kmeans(norm_mt[gene_marks, ], k)
gene_order_list <- tapply(names(cl$cluster), cl$cluster, function(gs) {
  cor_genes <- cor(t(norm_mt[gs,]))
  hclust_genes <- hclust(as.dist(1 - cor(cor_genes)), method = "ward.D2")
  rownames(cor_genes)[hclust_genes$order]
})
names(gene_order_list) <- unique(cl$cluster)
gene_order_list <- gene_order_list[as.character(seq_along(gene_order_list))]

# cluster clusters
cluster_order <- hclust(
  dist(cor(t(cl$centers)),
  method = "euclidean"),
  method = "ward.D2"
)$order
gene_order_list <- gene_order_list[as.character(cluster_order)]
gene_order <- unname(unlist(gene_order_list[cluster_order]))
clusters_dt <- data.table(
  gene = unlist(gene_order_list),
  clusters = as.character(
    rep(names(gene_order_list), sapply(gene_order_list, length))
  )
)

# group clusters (manually)
clusters_dt[clusters %in% c(9,20,14,15,7), group:=1] # Elav
clusters_dt[clusters %in% c(17,4,13), group:=2] # Elav + Fox
clusters_dt[clusters %in% c(11,1), group:=3] # Fox
clusters_dt[clusters %in% c(19), group:=4] # Fox + Ncol
clusters_dt[clusters %in% c(10,18), group:=5] # Elav + Ncol
clusters_dt[clusters %in% c(16,12), group:=6] # Ncol
clusters_dt[clusters %in% c(5,2,3), group:=7]
clusters_dt[clusters %in% c(6), group:=8] 
clusters_dt[clusters %in% c(8), group:=9] 
setorder(clusters_dt, group)
gene_order <- clusters_dt$gene

# save
fwrite(clusters_dt, file.path(res_dir, "genes_clusters.tsv"), sep="\t")
```

Heatmap of markers

```{r fig.height=10, fig.width=8, warning=FALSE, message=FALSE}
# order rows and columns
samples_order <- col_dt[order(condition, reporterline)]$sample
plot_mt <- norm_mt[gene_order, samples_order]

# center at 0
plot_min <- quantile(abs(range(plot_mt)), 0.75)
plot_mt <- pmin(pmax(plot_mt, -plot_min), plot_min)

# heatmap colors
col_vec <- colorRampPalette(RColorBrewer::brewer.pal(11, 'BrBG'))(1000)
col_fun <- circlize::colorRamp2(
  seq(-plot_min, plot_min, length.out = length(col_vec)),
  col_vec
)

# color annotations
col_ann <- HeatmapAnnotation(
    which = "column",
    border = TRUE,
    "reporterline" = as.character(
      col_dt[match(colnames(plot_mt),sample)]$reporterline
    ),
    "condition" = as.character(
      col_dt[match(colnames(plot_mt),sample)]$condition
    ), 
    col = list("reporterline" = line_cols, "condition" = condition_cols)
)

# gene module annotations
clann <- clusters_dt[match(rownames(plot_mt),gene)]$clusters
clann_lab <- unique(clusters_dt[match(rownames(plot_mt), gene)]$clusters)
clann <- factor(clann, levels = clann_lab)
module_ann <- HeatmapAnnotation(
    which = "row", border = TRUE,
    "cluster" = anno_block(
      labels = clann_lab,
      gp = gpar(col = NA)
    )
)
row_split <- clann

# gene module annotations (manual groups)
grann <- clusters_dt[match(rownames(plot_mt), gene)]$group
grann_lab <- unique(clusters_dt[match(rownames(plot_mt), gene)]$group)
grann <- factor(grann, levels = grann_lab)
module_ann <- HeatmapAnnotation(
    which = "row", border = TRUE,
    "group" = anno_block(
      labels = grann_lab,
      gp = gpar(col = NA)
    )
)
row_split <- grann

# genes annotations
marks_gold <- fread(
  file.path("annotation", "golden-marks-230116.tsv"), 
  fill = TRUE
)[,1:2]
setnames(marks_gold, c("gene", "name"))
marks_gold[,name:=str_remove(name, "^Nv")]

tfs_annt <- fread(
  file.path("annotation","curated_TFh_Nvec_DToL_names.tsv"), 
  header = FALSE
)
setnames(tfs_annt, c("gene", "pfam", "og"))

marks_tfs <- merge.data.table(
  tfs_annt,
  marks_gold,
  by="gene", all=TRUE, sort=FALSE
)
marks_tfs[is.na(marks_tfs)] <- ""
marks_tfs <- marks_tfs[gene %in% rownames(plot_mt)]
marks_tfs <- marks_tfs[name != ""]

row_labels_marks_ids <- match(marks_tfs$gene, rownames(plot_mt))
row_labels_marks <- marks_tfs[
  match(rownames(plot_mt)[row_labels_marks_ids], gene)
]$name
mark_ann <- HeatmapAnnotation(
  which = "row", 
  marker = anno_mark(at = row_labels_marks_ids, labels = row_labels_marks),
  show_legend = FALSE
)

# heatmap
hm <- Heatmap(
  plot_mt, name = "normalized\nexpression",
  col = col_fun,
  cluster_rows = FALSE, cluster_columns = FALSE,
  show_row_names = FALSE, show_column_names = TRUE,
  row_title = "genes",
  row_split = row_split,
  cluster_row_slices = FALSE,
  top_annotation = col_ann, right_annotation = mark_ann,
  left_annotation = module_ann,
  border = TRUE
)
hm
```

```{r include=FALSE, eval=TRUE}
pdf(file.path(fig_dir, "clustering_heatmap.pdf"), width=8, height=10)
draw(hm)
dev.off()
```

## Gene classification

Train a model to classify genes in one of the groups defined above.  

First prepare input data.

```{r}
require(caret)
require(pROC)
set.seed(1950)

# input data
norm_mt <- read.table(file.path(res_dir, "norm_expression.tsv"), header = TRUE)
norm_dt <- as.data.table(norm_mt)[,gene := rownames(norm_mt)]
clusters_dt <- fread(file.path(res_dir, "genes_clusters.tsv"))
groups_dt <- merge.data.table(
  norm_dt, clusters_dt,
  by = "gene",
  all = TRUE
)
groups_dt[,clusters:=NULL]

# unknown data
dt_dt <- groups_dt[is.na(group)]
dt_dt[, group:=NULL]

# train test split
dt_tt <- groups_dt[!is.na(group)]
dt_tt[, group:=paste0("G", group)]
dt_tt[, group:=factor(
  group,
  levels = paste0("G", seq_along(unique(dt_tt$group)))
)]
df_tt <- as.data.frame(dt_tt[, -1], row.names = dt_tt$gene)
id_train <- sample(seq_len(nrow(df_tt)), round(nrow(df_tt) * 0.8))
id_test <- setdiff(seq_len(nrow(df_tt)), id_train)
df_train <- df_tt[id_train, ]
df_test <- df_tt[id_test, ]

# set up cross validation
ctrl <- trainControl(method = "cv",  number = 10, classProbs = TRUE)
```

### Random forest

```{r eval=FALSE}
set.seed(1950)
require(ranger)

# parameter grid search
hyper_grid <- expand.grid(
  splitrule = "gini",
  mtry = seq(2, 10, by = 2),
  min.node.size = seq(5, 20, by = 5)
)

# train models
rf_tree <- caret::train(
  x = df_train[, -ncol(df_train)],
  y = df_train[, "group"],
  method = "ranger",
  trControl = ctrl,
  tuneGrid = hyper_grid,
  num.trees =  500,
  importance = "none"
)
rf_tree

# predict
rf_pred <- predict(rf_tree, df_test)
rf_conf <- confusionMatrix(
  data = rf_pred,
  reference = df_test$group,
  mode = "prec_recall"
)
rf_conf$overall
# Accuracy : 0.8839138

# predict on unknown data
dt_dt[, group_rf:=predict(rf_tree, dt_dt)]
fwrite(
  dt_dt[, .SD, .SDcols = grep("gene|group",colnames(dt_dt))],
  file.path(res_dir, "genes_clusters_predicted.tsv"), 
  sep = "\t"
)

```

```{r include=FALSE, eval=FALSE}
# ROC
rf_probs <- predict(rf_tree, df_test, type = "prob")
rf_roc <- roc(
  predictor = colnames(rf_probs)[apply(rf_probs, 1, which.max)],
  response = df_test$group,
  levels = levels(df_test$group)
)
rf_roc$auc
plot(rf_roc, main = "RF ROC")
```

### GBM

```{r eval=FALSE}
set.seed(1950)

# parameter grid search
hyper_grid <- expand.grid(
  interaction.depth = c(1, 2),
  n.trees = c(200, 500, 1000),
  shrinkage = c(0.01, 0.1),
  n.minobsinnode = seq(5, 50, by = 5)
)

# train models
gbm_tree <- train(
  x = df_train[, -ncol(df_train)],
  y = df_train[, "group"],
  method = "gbm",
  trControl = ctrl,
  tuneGrid = hyper_grid,
  metric = "ROC"
)
gbm_tree

# predict
gbm_pred <- predict(gbm_tree, df_test)
gbm_conf <- confusionMatrix(
  data = gbm_pred,
  reference = df_test$group,
  mode = "prec_recall"
)
gbm_conf$overall
# Accuracy : 0.9021559

# predict on unknown data
dt_dt[, group_gbm:=predict(gbm_tree, dt_dt)]
fwrite(
  dt_dt[, .SD, .SDcols = grep("gene|group",colnames(dt_dt))],
  file.path(res_dir, "genes_clusters_predicted.tsv"), 
  sep = "\t"
)

```

### XGBoost

```{r eval=FALSE}
set.seed(1950)
require(xgboost)
registerDoParallel(4, cores = 4)
getDoParWorkers()

# parameter grid search
hyper_grid <- expand.grid(
  nrounds = 500,
  max_depth = c(2, 6, 10),
  eta = c(0.01, 0.1),
  gamma = 0,
  colsample_bytree = seq(0.5, 0.9, length.out = 5),
  min_child_weight = 1,
  subsample = 1
)

# train models
xgb_tree <- train(
  x = df_train[, -ncol(df_train)],
  y = df_train[, "group"],
  method = "xgbTree",
  metric = "ROC",
  trControl = ctrl,
  tuneGrid = hyper_grid
)
xgb_tree$bestTune

# predict
xgb_pred <- predict(xgb_tree, df_test)
xgb_conf <- confusionMatrix(
  data = xgb_pred,
  reference = df_test$group,
  mode = "prec_recall"
)
xgb_conf$overall
# Accuracy: 0.9087894

# predict on unknown data
dt_dt[, group_xgb:=predict(xgb_tree, dt_dt)]
fwrite(
  dt_dt[, .SD, .SDcols = grep("gene|group",colnames(dt_dt))],
  file.path(res_dir, "genes_clusters_predicted.tsv"), 
  sep = "\t"
)
```

Plot all genes heatmap

```{r fig.height=10, fig.width=8, warning=FALSE, message=FALSE}
# select model results
dt_dt <- fread(file.path(res_dir, "genes_clusters_predicted.tsv"))
dt_dt[, group := group_xgb]
dt_dt[, group := factor(
  group,
  levels = paste0("G", seq_along(unique(dt_dt$group)))
)]

# cluster genes within groups
gene_order_list <- tapply(dt_dt$gene, dt_dt$group, function(gs) {
  gs <- gs[gs %in% rownames(norm_mt)]
  cor_genes <- cor(t(norm_mt[gs, ]))
  cor_genes[is.na(cor_genes)] <- 0
  hclust_genes <- hclust(as.dist(1 - cor(cor_genes)), method = "ward.D2")
  rownames(cor_genes)[hclust_genes$order]
})
names(gene_order_list) <- levels(dt_dt$group)
gene_order <- unname(unlist(
  gene_order_list[as.character(levels(dt_dt$group))]
))

# order rows and columns for plotting
samples_order <- col_dt[order(condition, reporterline)]$sample
plot_mt <- norm_mt[gene_order, samples_order]

# center at 0
plot_min <- quantile(abs(range(plot_mt)), 0.75)
plot_min <- 5
plot_mt <- pmin(pmax(plot_mt, -plot_min), plot_min)

# heatmap colors
col_vec <- colorRampPalette(RColorBrewer::brewer.pal(11, 'BrBG'))(1000)
col_fun <- circlize::colorRamp2(
  seq(-plot_min, plot_min, length.out = length(col_vec)),
  col_vec
)

# color annotations
col_ann <- HeatmapAnnotation(
    which = "column",
    border = TRUE,
    "reporterline" = as.character(
      col_dt[match(colnames(plot_mt),sample)]$reporterline
    ),
    "condition" = as.character(
      col_dt[match(colnames(plot_mt),sample)]$condition
    ),
    col = list("reporterline" = line_cols, "condition" = condition_cols)
)

# gene module annotations (manual groups)
grann <- dt_dt[match(rownames(plot_mt), gene)]$group
grann_lab <- unique(dt_dt[match(rownames(plot_mt), gene)]$group)
grann <- factor(grann, levels = grann_lab)
grann_lab <- str_remove(grann_lab, "G")
module_ann <- HeatmapAnnotation(
    which = "row", border = TRUE,
    "group" = anno_block(
      labels = grann_lab,
      gp = gpar(col = NA)
    )
)
row_split <- grann

# genes annotations
marks_gold <- fread(
  file.path("annotation", "golden-marks-230116.tsv"),
  fill = TRUE
)[, 1:2]
setnames(marks_gold, c("gene", "name"))
marks_gold[, name:=str_remove(name, "^Nv")]

tfs_annt <- fread(
  file.path("annotation","curated_TFh_Nvec_DToL_names.tsv"), 
  header = FALSE
)
setnames(tfs_annt, c("gene", "pfam", "og"))

marks_tfs <- merge.data.table(
  tfs_annt,
  marks_gold,
  by="gene", all=TRUE, sort=FALSE
)
marks_tfs[is.na(marks_tfs)] <- ""
marks_tfs <- marks_tfs[gene %in% rownames(plot_mt)]
marks_tfs <- marks_tfs[name != ""]

row_labels_marks_ids <- match(marks_tfs$gene, rownames(plot_mt))
row_labels_marks <- marks_tfs[
  match(rownames(plot_mt)[row_labels_marks_ids], gene)
]$name
mark_ann <- HeatmapAnnotation(
  which = "row",
  marker = anno_mark(at = row_labels_marks_ids, labels = row_labels_marks),
  show_legend = FALSE
)

# heatmap
hm <- Heatmap(
  plot_mt, name = "normalized\nexpression",
  col = col_fun,
  cluster_rows = FALSE, cluster_columns = FALSE,
  show_row_names = FALSE, show_column_names = TRUE,
  row_title = "genes",
  row_split = row_split,
  cluster_row_slices = FALSE,
  top_annotation = col_ann,
  right_annotation = mark_ann,
  left_annotation = module_ann,
  border = TRUE
)
hm
```

```{r include=FALSE, eval=TRUE}
pdf(file.path(fig_dir, "clusters_prediction_heatmap.pdf"), width=8, height=10)
draw(hm)
dev.off()
```

## TFs

Identify expressed genes (and TFs) in groups that were defined by clustering.

```{r}
# TF annotation
tfs_annt <- fread(
  file.path("annotation", "curated_TFh_Nvec_DToL_names.tsv"),
  header = FALSE
)
setnames(tfs_annt, c("gene", "pfam", "og"))

# groupped genes
mark_dt <- fread(file.path(res_dir, "genes_clusters.tsv"))
mark_dt[, group:=paste0("G", group)]
gene_dt <- fread(file.path(res_dir, "genes_clusters_predicted.tsv"))
gene_dt[, group:=group_xgb]
group_dt <- rbindlist(list(
  clustered = mark_dt[, .(gene, group)],
  predicted = gene_dt[, .(gene, group)]
),  idcol = "method")
group_dt[, group:=factor(
  group,
  levels = paste0("G", seq_along(unique(group_dt$group)))
)]
length(group_dt$gene)

# expressed TFs
expr_genes <- names(which(apply(con_mt, 1, function(x) sum(x) > 10) == TRUE))
expr_tfs <- expr_genes[expr_genes %in% tfs_annt$gene]
length(expr_genes)
expr_dt <- group_dt[gene %in% expr_genes]
expr_dt[, TF := gene %in% expr_tfs]
expr_dt[, TF := factor(TF, levels = c(TRUE, FALSE))]
setorder(expr_dt, group, TF)

expr_dt[, .N, group]
expr_dt[, .N, .(group, TF)]
```

For how many of these TFs we don't have motifs?

```{r fig.height=5, fig.width=5}
# motifs
atac_dir <- "ATACSEQ/nucleosome_free_regions/results/"
pwms_fnm <- file.path(
  atac_dir,
  "motif-archetypes-PPM-PCCnorm-0.8-IC0.5-8bp-pwms.rds"
)
pwms <- readRDS(pwms_fnm)
names(pwms) <- sapply(pwms, function(x) x@name)
dict_fnm <- file.path(
  atac_dir,
  "motif-archetypes-PPM-PCCnorm-0.8-IC0.5-8bp.dict"
)
dict <- fread(dict_fnm)
mean(expr_tfs %in% dict$gene) # 0.16

tfs_dt <- merge.data.table(
  expr_dt[TF == TRUE][, TF := NULL],
  unique(dict[, .(gene, og, pfam, archetype, archetype_name)]),
  by = "gene", all.x = TRUE, sort = FALSE
)

dt_tf_1 <- unique(
  tfs_dt[, .(gene, archetype, group)][
    order(archetype)][
      , .SD[1], gene]
)
gp_tf_1 <- ggplot(
  dt_tf_1, 
  aes(group, fill = !is.na(archetype))) +
  geom_bar() +
  scale_fill_manual(
    "",
    values = c("TRUE" = "#0ab30a", "FALSE" = "#b41b1b"),
    labels = c(
      "TRUE" = sprintf(
        "motif (%i)",
        length(unique(dt_tf_1[!is.na(archetype)]$gene))
      ),
      "FALSE" = sprintf(
        "no motif (%i)",
        length(unique(dt_tf_1[is.na(archetype)]$gene))
      )
    )
  ) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.01))) +
  labs(y = "all TFs", x = "")

dt_tf_2 <- unique(
  tfs_dt[method == "clustered"][
    , .(gene, archetype, group)][
      order(archetype)][
        , .SD[1], gene]
)
gp_tf_2 <- ggplot(
  dt_tf_2,
  aes(group, fill = !is.na(archetype))) +
  geom_bar() +
  scale_fill_manual(
    "",
    values = c("TRUE" = "#0ab30a", "FALSE" = "#b41b1b"),
    labels = c(
      "TRUE" = sprintf(
        "motif (%i)",
        length(unique(dt_tf_2[!is.na(archetype)]$gene))
      ),
      "FALSE" = sprintf(
        "no motif (%i)",
        length(unique(dt_tf_2[is.na(archetype)]$gene))
      )
    )
  ) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.01))) +
  labs(y = "marker TFs", x = "")

gp_ft <- (gp_tf_1 / gp_tf_2 & theme(
  legend.position = "top",
  panel.grid.major.y = element_line(size = 0.5)
  ))
gp_ft
```

```{r include=FALSE, eval=TRUE}
pdf(file.path(fig_dir, "motifs-tfs-groups.pdf"), width = 5, height = 7)
gp_ft
dev.off()
```

We will focus on marker TFs. 

Inspect those TFs for which there are motifs.

```{r}
mot_tfs_dt <- unique(
  tfs_dt[!is.na(archetype)][
    method == "clustered"][
      , .(gene, og, pfam, archetype, archetype_name)]
)
mot_tfs_dt[,.N,gene]

# genes annotations
marks_gold <- fread(
  file.path("annotation", "golden-marks-230116.tsv"),
  fill = TRUE
)[, 1:2]
setnames(marks_gold, c("gene", "name"))
marks_gold[, name:=str_remove(name, "^Nv")]

mot_tfs_dt <- merge.data.table(
  mot_tfs_dt,
  marks_gold,
  by="gene", all.x = TRUE, sort = FALSE
)
mot_tfs_dt[is.na(mot_tfs_dt)] <- ""
mot_tfs_dt

mot_tfs_pwm <- pwms[mot_tfs_dt$archetype]
mot_tfs_pwm <- lapply(mot_tfs_pwm, function(x) {
  x@alphabet <- "DNA"
  x
})
log_dir <- file.path(fig_dir, "logo")
dir.create(log_dir, showWarnings = FALSE)
mot_tfs_log <- lapply(unique(mot_tfs_dt$gene), function(g) {
  i <- mot_tfs_dt[gene==g]$archetype
  vm <- view_motifs(
    motifs = mot_tfs_pwm[i],
    show.positions.once = TRUE,
    names.pos = "top"
  )
  nm <- mot_tfs_dt[gene==g]$name[1]
  if (nm == "") {
    nm <- g
  } else {
    nm <- sprintf("%s %s", nm, g)
  }
  vm <- vm + labs(title=nm)
  pdf(
    file.path(
      log_dir, 
      sprintf(
        "archetypes-%s.pdf", 
        str_replace_all(nm, c(" " = "-", "/" = "_"))
      )
    ),
    width = 5, height = pmax(2, length(i))
  )
  print(vm)
  dev.off()
})
```

Inspect missing TFs and motifies across TF families

```{r fig.height=6, fig.width=6, message=FALSE, warning=FALSE, echo=FALSE}
TF_family_annotation_file <- file.path(
  "annotation", "gene_families_searchinfo.csv"
)
tf_fams <- fread(TF_family_annotation_file)

# TFs with no motif
orp_tfs_dt <- merge.data.table(
  tfs_dt[is.na(archetype)][method == "clustered"][, .(gene, group)],
  tfs_annt,
  by = "gene"
)
# get family info from gene og
orp_tfs_dt[og != "", tf_family := str_remove(og, "\\.(?<=\\.).+")]
orp_tfs_dt[, tf_family := str_replace_all(tf_family, "AP2", "AP-2")]
# summarize
orp_tfs_dtn <- orp_tfs_dt[, .N, tf_family][,prop := N/sum(N)][order(-N)]
orp_tfs_dtn[, tf_family := factor(tf_family, levels = orp_tfs_dtn$tf_family)]

# motifs with no TFs
arc_dt <- unique(dict[gene!=""][
  ,.(archetype_name,gene)])[
    ,.(number_of_genes=.N),archetype_name][
      order(number_of_genes)]
orp_arc <- unique(
  dict[!archetype_name %in% arc_dt$archetype_name]$archetype_name
)
orp_arc_dt <- dict[archetype_name %in% orp_arc]
# get family info from archetype name
orp_arc_dt[
  tf_family == "",
  tf_family := str_extract(archetype_name, paste(tf_fams[[1]], collapse = "|"))
]
# get family info from motifs names
orp_arc_na <- orp_arc_dt[is.na(tf_family),][
  ,tf_family:=str_extract(motif,paste(tf_fams[[1]],collapse="|"))][
    ,.(archetype,tf_family)][
      !is.na(tf_family)]
orp_arc_vc <- structure(orp_arc_na$tf_family, names=orp_arc_na$archetype)
orp_arc_dt[archetype %in% names(orp_arc_vc), tf_family:=orp_arc_vc[archetype]]
# guess family info from archetype names
grep_list2 <- list(
  "fox" = "Forkhead",
  "hox" = "Homeodomains",
  "sox" = "HMGbox_Sox",
  "runx|runt" = "Runt_Runx",
  "mads|srf" = "MADS-box_SRF",
  "Myb_DNA-bind" = "Myb"
)
nms <- unlist(strsplit(tf_fams[[2]], ","))
fms <- unname(unlist(lapply(seq_len(nrow(tf_fams)), function(i) 
  rep(tf_fams[i, 1], length(strsplit(as.character(tf_fams[i, 2]), ",")[[1]]))
)))
grep_list1 <- fms; names(grep_list1) <- nms
grep_list <- c(grep_list1, grep_list2)
for (gp in names(grep_list)) {
  orp_arc_dt[
    is.na(tf_family) & grepl(gp, archetype, ignore.case = TRUE), 
    tf_family:=grep_list[[gp]]
  ]
}
orp_arc_dt[, tf_family:=str_replace_all(tf_family, "AP2", "AP-2")]
orp_arc_dt[is.na(tf_family), tf_family:="unknown"]
# subset for families of TFs without motif
orp_arc_dtn <- orp_arc_dt[tf_family %in% as.character(orp_tfs_dtn$tf_family)]
# summarize
orp_arc_dtn <- orp_arc_dt[,.N,tf_family][,prop:=N/sum(N)][order(-N)]
orp_arc_dtn[,tf_family:=factor(tf_family, levels=orp_arc_dtn$tf_family)]


# colors
tf_fams <- unique(sort(c(tf_fams[[1]], unique(orp_tfs_dt$tf_family))))
tf_fams <- tf_fams[tf_fams %in% c(
  as.character(orp_tfs_dtn$tf_family),
  as.character(orp_arc_dt$tf_family)
)]
tf_fams <- str_replace_all(tf_fams, "AP2", "AP-2")
tf_fams_cols <- structure(c(
  colorRampPalette(RColorBrewer::brewer.pal(8, 'Paired'))(length(tf_fams)),
  "khaki", 
  "grey"
), names = c(tf_fams, "other", "unknown"))

# plots
gp_orp_tfs <- ggplot(orp_tfs_dtn, aes("", N, fill = tf_family)) +
  geom_bar(stat = "identity", width = 1, color = "black") +
  coord_polar("y", start = 0) +
  scale_fill_manual(values = tf_fams_cols, limits = force) +
  geom_text(
    aes(label = ifelse(
      N < 1,
      "",
      sprintf("%s (%s)", tf_family, N)
    ), x = 1.4),
    position = position_stack(vjust = 0.5),
    color = "black"
  ) +
  labs(title = "orphan TFs") +
  theme_void() +
  theme(legend.position = "none")

gp_orp_arc <- ggplot(orp_arc_dtn, aes("", N, fill = tf_family)) +
  geom_bar(stat = "identity", width = 1, color = "black") +
  coord_polar("y", start=0) +
  scale_fill_manual(values = tf_fams_cols, limits = force) +
  geom_text(
    aes(label = ifelse(
      N < 1,
      "",
      sprintf("%s (%s)", tf_family, N)
    ), x = 1.4),
    position = position_stack(vjust = 0.5),
    color = "black"
  ) +
  labs(title = "orphan motif archetypes") +
  theme_void() +
  theme(legend.position = "none")

# plot
gp_orp_tfs + gp_orp_arc
```

```{r include=FALSE, eval=TRUE}
pdf(file.path(fig_dir, "motifs-archetypes-tf-orphans.pdf"), width=10, height=5)
gp_orp_tfs + gp_orp_arc
dev.off()
```

```{r fig.height=5, fig.width=6}
orp_dtn <- rbindlist(list(
  "TFs" = orp_tfs_dtn,
  "archetypes" = orp_arc_dtn
), idcol = "variable")
orp_dtn <- orp_dtn[tf_family!="unknown"]

gp_orp <- ggplot(orp_dtn, aes(tf_family)) + 
  geom_bar(
    data = subset(orp_dtn, variable == "TFs"), 
    aes(y = -N, fill = tf_family), 
    stat = "identity", position = "dodge", color = "black") +
  geom_bar(
    data = subset(orp_dtn, variable == "archetypes"), 
    aes(y = N, fill = tf_family), 
    stat = "identity", position = "dodge", color = "black") + 
  coord_flip() +
  scale_fill_manual(values = tf_fams_cols, limits = force) +
  scale_y_continuous(limits = c(NA, NA), labels = abs) +
  # geom_hline(yintercept = 0,colour = "black") +
  theme(
    legend.position = "none", 
    panel.grid.major.x = element_line(size=0.5)) +
  labs(y="TFs\tmotifs", x="TF family")
gp_orp
```

```{r include=FALSE, eval=TRUE}
pdf(file.path(fig_dir, "motifs-archetypes-tf-orphans-counts.pdf"), width=6, height=5)
gp_orp
dev.off()
```
