---
title: "02. ATACseq"
format:
  html:
    toc: true
    toc-location: left
editor: visual
---

## Setup

Load packages

```{r warning=FALSE, message=FALSE, results = FALSE}
library(data.table)
library(stringr)
library(ggplot2)
theme_py <- theme_light() + theme(
  panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(),
  panel.border = element_rect(colour = "black", fill = NA),
  text = element_text(size=20),
  strip.placement = "outside", 
  strip.text = element_text(size=20, color="black"),
  strip.background = element_rect(fill="white")
)
theme_set(theme_py)
library(patchwork)
library(ggrepel)
library(ComplexHeatmap)
library(DESeq2)
library(consensusSeekeR)
library(BSgenome.jaNemVect1.1.DToL.Assembly)
library(GenomicRanges)
library(parallel)
```

Directories

```{r}
dat_dir <- "ATACSEQ/nucleosome_free_regions/"
pks_dir <- file.path(dat_dir, "macs2_peaks")
cns_dir <- file.path(dat_dir, "consensus_peaks")
hom_dir <- file.path(dat_dir, "homer")
res_dir <- file.path(dat_dir, "results")
fig_dir <- file.path(dat_dir, "plots")
for (newdir in c(cns_dir, hom_dir, res_dir, fig_dir))
  dir.create(newdir, showWarnings = FALSE)
```

## Peaks counts normalization

Find consensus set of peaks

```{r eval=FALSE}
require(consensusSeekeR)
require(BSgenome.jaNemVect1.1.DToL.Assembly)
require(parallel)

# load peaks
pks_files <- list.files(pks_dir, pattern="narrowPeak", recursive=FALSE, full.names=TRUE)
names(pks_files) <- str_remove(basename(pks_files), ".mLb.clN.ncfree_peaks.narrowPeak")
nP_list <- lapply(names(pks_files), function(x) {
    nP <- readNarrowPeakFile(pks_files[x], extractRegions = TRUE, extractPeaks = TRUE)
    names(nP$narrowPeak) <- rep(x, length(nP$narrowPeak))
    names(nP$peak) <- rep(x, length(nP$peak))
    nP
})
regions <- GenomicRanges::GRangesList(lapply(nP_list, function(x) x$narrowPeak))
peaks <- GenomicRanges::GRangesList(lapply(nP_list, function(x) x$peak))
names(regions) <- names(pks_files)
names(peaks) <- names(pks_files)

# get consensus
chrList <- Seqinfo(
    seqnames = seqnames(BSgenome.jaNemVect1.1.DToL.Assembly),
    seqlengths = seqlengths(BSgenome.jaNemVect1.1.DToL.Assembly),
    isCircular = c(rep(FALSE, length(seqnames(BSgenome.jaNemVect1.1.DToL.Assembly))-1), TRUE),
    genome = "jaNemVect1.1"
)
message(Sys.time(), " Started calculating consensus")
ur <- unlist(regions)
up <- unlist(peaks)

# debugging
# id <- seqnames(ur)=="NC_064035.1" & start(ur)>1644829 & end(ur)<1649211
# ur <- ur[id]
# up <- up[id]
# chrList <- chrList["NC_064035.1"]

results <- findConsensusPeakRegions(
    narrowPeaks = ur,
    peaks = up,
    chrInfo = chrList,
    extendingSize = 250,
    expandToFitPeakRegion = FALSE,
    shrinkToFitPeakRegion = FALSE,
    minNbrExp = 2,
    nbrThreads = detectCores()-1
)
message(Sys.time(), " Done calculating consensus")
saveRDS(results, file.path(cns_dir,"consensusSeekeR-results.RDS"))

# resize peaks
pks_cns <- results$consensusRanges
pks_mid <- start(pks_cns) + (end(pks_cns)-start(pks_cns))/2
ranges(pks_cns) <- IRanges(pks_mid,width=0)
pks_scl <- promoters(pks_cns, upstream=125, downstream=125)

# trim out-of-bound peaks
seqlengths(pks_scl) <- seqlengths(BSgenome.jaNemVect1.1.DToL.Assembly)[names(seqlengths(pks_scl))]
pks_scl <- trim(pks_scl)

# save bed file
pks_bed <- as.data.table(pks_scl)
pks_bed[,name:=paste0("peak",1:.N)]
pks_bed[,width:=NULL][,score:="."]
setcolorder(pks_bed, c("seqnames","start","end","name","score","strand"))
fwrite(pks_bed, file.path(cns_dir,"consensusSeekeR-peaks.bed"), sep="\t", col.names=FALSE)
```

Get scores for consensus peaks in all samples.

```{r include=FALSE, eval=FALSE}
# load consensus peaks
pks_bed <- fread(file.path(cns_dir,"consensusSeekeR-peaks.bed"))
setnames(pks_bed, c("seqnames", "start", "end", "name", "score", "strand"))
pks_grn <- makeGRangesFromDataFrame(pks_bed, keep.extra.columns = TRUE)

# get counts in consensus peaks
bws_files <- list.files(file.path(dat_dir, "bigwig"), pattern = ".bigwig", full.names = TRUE)
bws_names <- str_remove(basename(bws_files),".mLb.clN.ncfree.bigwig")
names(bws_files) <- bws_names
bws_signal <- rbindlist(lapply(bws_names, function(smp){
  as.data.table(import(bws_files[smp]))[,sample:=smp][]
}))

# overlap signal with consensus peaks
pks_list <- lapply(bws_names, function(smp) {
  bw_dt <- bws_signal[sample==smp]
  bw_gr <- makeGRangesFromDataFrame(bw_dt, keep.extra.columns = TRUE)
  # ovl
  ovl <- findOverlaps(query = bw_gr, subject = pks_grn)
  ps_dt <- as.data.table(pks_grn[subjectHits(ovl)])
  scs <- mcols(bw_gr[queryHits(ovl)])$score
  ps_dt[,score:=scs]
  # non ovl
  if (any(!pks_grn$name %in% ps_dt$name)) {
    message("Adding missing peks for ", smp)
    ps_dt <- rbindlist(list(
      ps_dt,
      as.data.table(pks_grn)[!name %in% ps_dt$name][,score:=0]
    ), use.names = TRUE)
  }
  ps_dt[,sample:=smp][]
})
pks_dt <- rbindlist(pks_list)

# keep max signal in each peak
pks_dt[,score:=as.numeric(score)]
pkt_dt <- pks_dt[order(name,-score)][,.SD[1],.(name,sample)]
pkt_dt[,seqnames:=factor(seqnames, levels=levels(seqnames(pks_grn)))]
setorder(pkt_dt, seqnames, start, end)

# save bed file
pkt_dt[,width:=NULL]
setcolorder(pkt_dt, c("seqnames", "start", "end", "name", "score", "strand", "sample"))
fwrite(pkt_dt, file.path(cns_dir,"consensusSeekeR-peaks-samples.bed"), sep="\t", col.names=FALSE)
```

```{bash eval=FALSE}
nth=12
res="ATACSEQ/nucleosome_free_regions/consensus_peaks/consensusSeekeR-peaks-counts.tsv"
bed="ATACSEQ/nucleosome_free_regions/consensus_peaks/consensusSeekeR-peaks.bed"
bam=$( echo ATACSEQ/nucleosome_free_regions/bam/*R*bam )

cols=$( echo -e seqnames start end name score strand | column -t )
for b in $bam
do 
  echo $b
  name=$( basename $b)
  cols=$( echo -e ${cols} ${name} | column -t )
done

echo -e ${cols} > ${res%%tsv}txt
bedtools multicov -bams ${bam} -bed ${bed} > ${res}
```

Data for differential peaks analysis

```{r}
# load counts in peaks
pks_ct <- fread(file.path(cns_dir, "consensusSeekeR-peaks-counts.tsv"), header=FALSE)
colnames <- readLines(file.path(cns_dir, "consensusSeekeR-peaks-counts.txt"), n=1)
colnames <- str_remove_all(colnames, ".mLb.clN.ncfree.sorted.bam")
colnames <- str_split(colnames, " ")[[1]]
colnames(pks_ct) <- colnames

# column data
condition_cols <- c("positive"="blue","negative"="red") 
line_cols = c("Elav" = "#ff7f00", "Fox" = "#984ea3", "Ncol" = "#4daf4a")

col_dt <- data.table(sample=colnames(pks_ct)[7:28])
col_dt[,reporterline:=str_extract(sample,"Elav|Fox|Ncol")]
col_dt[,reporterline:=factor(reporterline, levels=c("Elav","Fox","Ncol"))]
col_dt[,condition:=str_extract(sample,"pos|neg")]
col_dt[,condition:=str_replace_all(condition,c("pos"="positive","neg"="negative"))]
col_dt[,condition:=factor(condition, levels = c("negative","positive"))]
col_dt[,group:=paste(as.character(reporterline), as.character(condition), sep=""), by=1:nrow(col_dt)]
col_dt[,group:=factor(group)]

col_df <- copy(col_dt)
class(col_df) <- "data.frame"
rownames(col_df) <- col_df$sample

# counts matrix
pks_mt <- as.matrix(pks_ct[,-c(1:6)])
rownames(pks_mt) <- pks_ct$name
pks_mt <- pks_mt[,rownames(col_df)]

# DESeq2
require(DESeq2)
dds <- DESeqDataSetFromMatrix(
  countData = pks_mt,
  colData = col_df,
  design = ~ condition + reporterline
)
saveRDS(dds, file.path(res_dir, "dds.rds"))
```

## Marker peaks

Peaks counts distributions

```{r fig.width=8, fig.height=6, warning=FALSE, message=FALSE}
# normalized accessibility distribution
pks_dt <- as.data.table(pks_mt, keep.rownames = "peak")
pks_dt <- melt.data.table(pks_dt, id.vars = "peak", variable.name = "sample", value.name = "norm_counts")
pks_dt <- merge.data.table(pks_dt, col_dt, by="sample")
setorder(pks_dt, peak, condition, reporterline)
pks_dt[,sample:=factor(sample, levels = unique(pks_dt$sample))]

gp_acc <- ggplot(pks_dt, aes(sample, log10(norm_counts), fill=reporterline)) +
  geom_violin(scale = "width", alpha = 0.8, color = "black") +
  geom_boxplot(width = 0.5, outlier.shape = NA, alpha = 0.8, color = "black") + 
  scale_fill_manual(values = line_cols, limits = force) +
  scale_y_continuous(expand = expansion(mult = c(0,0.01))) +
  labs(x="samples", y="peak\naccessibility") +
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
    legend.title = element_blank(), legend.position = "none"
  )

var_dt <- pks_dt[,.(var=var(norm_counts)),.(peak)]
gp_var <- ggplot(var_dt, aes(log10(var))) + 
  geom_density() +
  scale_x_continuous(limits=c(-4,NA)) +
  scale_y_continuous(expand = expansion(mult = c(0,0.01))) +
  labs(x = "log10(accessibility variance)")

gp_pch <- gp_acc / gp_var + plot_layout(heights = c(2,1))
gp_pch
```

```{r include=FALSE, eval=TRUE}
pdf(file.path(fig_dir, "peaks_var_norm.pdf"), width=8, height=6)
gp_pch
dev.off()
```

Use normalized log-transformed accessibility data

```{r}
# log transformation
norm_mt <- (pks_mt+10)/apply(pks_mt+10,1,median) # row normalize to bring peaks to same range
norm_mt <- log2(norm_mt)

# varance sabilizing transformation
# dds <- readRDS(file.path(res_dir, "dds.rds"))
# vsd <- vst(dds, blind=FALSE)
# norm_mt <- vsd@assays@data[[1]]
# norm_mt <- (pks_mt+10)/apply(pks_mt+10,1,median) # row normalize to bring peaks to same range

```

Identify marker peaks

```{r include=FALSE, eval=TRUE}
# peak markers by normalized accessibility
peaks_fc <- names(which(apply(norm_mt, 1, function(x) sort(x,decreasing=TRUE)[2])>=2))
peaks_vari <- names(which(apply(norm_mt, 1, function(x) var(x)>1)))
peaks_marks_1 <- intersect(peaks_fc, peaks_vari)
length(peaks_marks_1)
```

```{r include=FALSE, eval=FALSE}
# peak markers by normalized accessibility + significant kruskall wallis
factor <- paste0(col_dt$condition, col_dt$reporterline)
kw_pvals <- apply(norm_mt, 1, function(x) kruskal.test(x~factor)$p.value)
kw_qvals <- p.adjust(kw_pvals, method="BH")
kw_peaks <- names(which(kw_qvals<0.05))
peaks_high <- names(which(apply(norm_mt, 1, function(x) sort(x,decreasing=TRUE)[2])>2))
peaks_marks_2 <- intersect(peaks_high, kw_peaks)
```

```{r include=TRUE, eval=TRUE}
# gene markers by high FC + significant DEseq2 LTR test 
dds <- readRDS(file.path(res_dir, "dds.rds"))
dds <- DESeq(dds, test="LRT", reduced=~1)
dds_res <- results(dds)
dds_qval <- dds_res$padj 
names(dds_qval) <- rownames(dds_res)
peaks_deseq <- names(which(dds_qval<1e-2))
peaks_high <- names(which(apply(norm_mt, 1, function(x) sort(x,decreasing = T)[2])>=1.8))
peaks_marks <- intersect(peaks_high, peaks_deseq)
length(peaks_marks)
```

Cluster peaks

```{r}
set.seed(1950)

# determine k for kmeans
ks <- 1:25
tot_withinss <- sapply(ks,  function(k) {
  cl <- kmeans(norm_mt[peaks_marks,], k)
  cl$tot.withinss
})
elbow_dt <- data.table(k = ks, tot_withinss = tot_withinss)
elbow_gp <- ggplot(elbow_dt, aes(x = k, y = tot_withinss)) +
  geom_line() + geom_point()+
  scale_x_continuous(breaks = ks)
elbow_gp
```

```{r include=FALSE, eval=TRUE}
pdf(file.path(fig_dir, "kmeans_elbow.pdf"), width=8, height=6)
elbow_gp
dev.off()
```

Cluster peaks

```{r}
# kmeans
set.seed(1950)
k <- 15
cl <- kmeans(norm_mt[peaks_marks,], k)
peaks_order_list <- tapply(names(cl$cluster), cl$cluster, function(gs) {
  cor_peaks <- cor(t(norm_mt[gs,]))
  hclust_peaks <- hclust(as.dist(1-cor(cor_peaks)),method="ward.D2")
  rownames(cor_peaks)[hclust_peaks$order]
})
names(peaks_order_list) <- unique(cl$cluster)
peaks_order_list <- peaks_order_list[as.character(seq_along(peaks_order_list))]

# cluster clusters
cluster_order <- hclust(dist(cor(t(cl$centers)),method="euclidean"),method="ward.D2")$order
peaks_order_list <- peaks_order_list[as.character(cluster_order)]
peaks_order <- unname(unlist(peaks_order_list))
clusters_dt <- data.table(
  peak = peaks_order,
  clusters = as.character(rep(names(peaks_order_list), sapply(peaks_order_list, length)))
)

# group clusters (manually)
clusters_dt[clusters %in% c(8), group:=1] # Elav
clusters_dt[clusters %in% c(9), group:=2]
clusters_dt[clusters %in% c(14), group:=3] # Fox
clusters_dt[clusters %in% c(13,5), group:=4]
clusters_dt[clusters %in% c(10,2), group:=5] 
clusters_dt[clusters %in% c(6,7,3,11,12), group:=6] # Ncol
clusters_dt[clusters %in% c(15), group:=7] 
clusters_dt[clusters %in% c(1), group:=8] 
clusters_dt[clusters %in% c(4), group:=9] 
setorder(clusters_dt, group)
peaks_order <- clusters_dt$peak

# add clusters info to peaks coordinates bed file
pks_bed <- fread(file.path(cns_dir,"consensusSeekeR-peaks.bed"))
setnames(pks_bed, c("V4"), c("peak"))
clusters_bed <- merge.data.table(pks_bed, clusters_dt, by="peak", sort = FALSE)
setcolorder(clusters_bed, c(colnames(pks_bed)))
clusters_bed[,clusters:=paste0("C",clusters)]
clusters_bed[,group:=paste0("G",group)]
fwrite(clusters_bed, file.path(res_dir, "consensusSeekeR-peaks-clusters.bed"), sep="\t", col.names = FALSE)
```

Heatmap of markers

```{r fig.height=10, fig.width=8, warning=FALSE, message=FALSE}
# order rows and columns
samples_order <- col_dt[order(condition,reporterline)]$sample
plot_mt <- norm_mt[peaks_order,samples_order]

# center at 0
plot_min <- quantile(abs(range(plot_mt)),0.75)
plot_min <- 5
plot_mt <- pmin(pmax(plot_mt,-plot_min),plot_min) 

# heatmap colors
col_vec <- colorRampPalette(RColorBrewer::brewer.pal(11,'BrBG'))(1000)
col_fun <- circlize::colorRamp2(seq(-plot_min, plot_min, length.out = length(col_vec)), col_vec)

# color annotaitons
col_ann <- HeatmapAnnotation(
    which = "column", border = TRUE,
    "reporterline" = as.character(col_dt[match(colnames(plot_mt),sample)]$reporterline),
    "condition" = as.character(col_dt[match(colnames(plot_mt),sample)]$condition), 
    col = list("reporterline" = line_cols, "condition" = condition_cols)
)

# peak module annotations
clann <- clusters_dt[match(rownames(plot_mt),peak)]$clusters
clann_lab <- unique(clusters_dt[match(rownames(plot_mt),peak)]$clusters)
clann <- factor(clann, levels=clann_lab)
grann <- clusters_dt[match(rownames(plot_mt),peak)]$group
grann_lab <- unique(clusters_dt[match(rownames(plot_mt),peak)]$group)
grann <- factor(grann, levels=grann_lab)
module_ann <- HeatmapAnnotation(
    which = "row", border = TRUE,
    # "cluster" = anno_block(
    #   labels = clann_lab,
    #   gp = gpar(col=NA)
    # ),
    "group" = anno_block(
      labels = grann_lab,
      gp = gpar(col=NA)
    )
)

# peaks annotations
row_labels_marks_ids <- match(clusters_dt[,.SD[1],clusters]$peak, rownames(plot_mt))
row_labels_marks <- clusters_dt[,.SD[1],clusters]$clusters
mark_ann <- HeatmapAnnotation(
  which = "row", 
  marker = anno_mark(at = row_labels_marks_ids, labels = row_labels_marks),
  show_legend = FALSE
)
mark_ann <- HeatmapAnnotation(
    which = "row", border = TRUE,
    "padj<0.05" = rownames(plot_mt) %in% peaks_deseq,
    "var>1" = rownames(plot_mt) %in% peaks_vari,
    "FC>2" = rownames(plot_mt) %in% peaks_fc,
    col = list(
      "padj<0.05" = c("TRUE" = "#e6ab02", "FALSE"="#d9d9d9"),
      "var>1" = c("TRUE" = "#3690c0", "FALSE"="#d9d9d9"),
      "FC>2" = c("TRUE" = "#e7298a", "FALSE"="#d9d9d9")
    )
)

# heatmap
hm <- Heatmap(
  plot_mt, name = "normalized\naccessibility",
  col = col_fun,
  cluster_rows = FALSE, cluster_columns = FALSE,
  show_row_names = FALSE, show_column_names = TRUE,
  row_title = "peaks", 
  row_split = grann, 
  cluster_row_slices = FALSE,
  top_annotation = col_ann,  
  left_annotation = module_ann, right_annotation = mark_ann,
  border = TRUE
)
hm
```

```{r include=FALSE, eval=TRUE}
pdf(file.path(fig_dir, "peaks_heatmap_group.pdf"), width=8, height=10)
draw(hm)
dev.off()
```

## PCA

PCA on all samples.

```{r fig.width=8, fig.height=10, warning=FALSE}
set.seed(1950)
pca_res <- prcomp(t(norm_mt), center = TRUE)

# variance explained
pca_var <- data.table(pct_var = round(((pca_res$sdev) ^ 2 / sum((pca_res$sdev) ^ 2)* 100), 2))
pca_var[,pct_cum:=cumsum(pct_var)]
pca_var[,PC:=factor(1:.N)]
gp_var <- ggplot(pca_var, aes(PC, pct_var)) + 
  geom_bar(stat = "identity") +
  geom_line(aes(y = pct_cum, group = 1)) + 
  geom_point(aes(y = pct_cum)) +
  scale_y_continuous(expand = expansion(0.01,0)) +
  labs(y = "% of variance\nexplained", x = "PC") +
  theme(panel.grid.major.y = element_line(size = 0.5))

pca_dt <- as.data.table(pca_res$x, keep.rownames = "sample")
pca_dt <- merge.data.table(col_dt, pca_dt, by="sample", sort=FALSE)
gp_bip <- ggplot(pca_dt, aes(PC1, PC2, fill=reporterline, shape=condition)) + 
  geom_point(size=5) +
  scale_fill_manual(values = line_cols) +
  scale_shape_manual(values = c("positive" = 21, "negative" = 24)) +
  guides(fill = guide_legend(override.aes=list(shape=21))) +
  geom_text_repel(aes(label = sample))

gp_pch <- gp_var / gp_bip 
gp_pch
```

```{r include=FALSE, eval=TRUE}
pdf(file.path(fig_dir, "PCA_all.pdf"), width=8, height=10)
gp_pch
dev.off()
```

PCA per cell line

```{r fig.height=8, fig.width=7}
set.seed(1950)

gp_l <- lapply(names(line_cols), function(cl) {
  
  pca_res <- prcomp(t(norm_mt[,grep(cl,colnames(norm_mt))]), center = TRUE)
  
  # variance explained
  pca_var <- data.table(pct_var = round(((pca_res$sdev) ^ 2 / sum((pca_res$sdev) ^ 2)* 100), 2))
  pca_var <- pca_var[-nrow(pca_var)]
  pca_var[,pct_cum:=cumsum(pct_var)]
  pca_var[,PC:=factor(1:.N-1)]
  gp_var <- ggplot(pca_var, aes(PC, pct_var)) + 
    geom_bar(stat = "identity") +
    geom_line(aes(y = pct_cum, group = 1)) + 
    geom_point(aes(y = pct_cum)) +
    scale_y_continuous(expand = expansion(0.01,0)) +
    labs(y = "% of variance\nexplained", x = "PC") +
    theme(panel.grid.major.y = element_line(size = 0.5))
  
  # pca plot
  pca_dt <- as.data.table(pca_res$x, keep.rownames = "sample")
  pca_dt <- merge.data.table(col_dt, pca_dt, by="sample", sort=FALSE)
  gp_bip <- ggplot(pca_dt, aes(PC1, PC2, fill=condition, shape=condition)) + 
    geom_point(size=5) +
    scale_shape_manual(values = c("positive" = 21, "negative" = 24)) +
    scale_fill_manual(values = condition_cols) +
    guides(fill = guide_legend(override.aes=list(shape=21))) +
    geom_text_repel(aes(label = sample))
  
  gp_var / gp_bip 

})
gp_l
```

```{r include=FALSE, eval=TRUE}
pdf(file.path(fig_dir, "PCA_reporter_lines.pdf"), width=7, height=8)
gp_l
dev.off()
```

## Differntial peak analysis

Differential analysis with DESeq2

```{r, eval=TRUE}
# all positive vs negative
dds_cond <- DESeqDataSetFromMatrix(
  countData = pks_mt,
  colData = col_df,
  design = ~ condition
)
dds_cond <- DESeq(dds_cond)

# condition within reporter line line
dds_conl <- DESeqDataSetFromMatrix(
  countData = pks_mt,
  colData = col_df,
  design = ~ group
)
dds_conl <- DESeq(dds_conl)

```

Function for MA plots

```{r}
ggplotMA <- function(res, padj_thr=0.05,sign_col="red",lims_fc=c(NA,NA),lims_mean=c(NA,NA),title="") {
  res_dt <- as.data.table(res)
  res_dt[log2FoldChange<lims_fc[1], log2FoldChange:=lims_fc[1]]
  res_dt[log2FoldChange>lims_fc[2], log2FoldChange:=lims_fc[2]]
  gp <- ggplot(res_dt, aes(x=baseMean, y=log2FoldChange, colour=padj<padj_thr)) + 
    geom_point(size=0.5) + 
    scale_color_manual(values = c("FALSE"="grey", "TRUE"=sign_col), name = sprintf("p.adjusted < %s",padj_thr)) +
    guides(colour = guide_legend(override.aes = list(size=4))) +
    scale_y_continuous(limits = lims_fc, expand = expansion(mult = c(0.01,0.01))) +
    scale_x_continuous(limits = lims_mean) +
    geom_hline(aes(yintercept = 0), size = 1) +
    labs(
      x = "mean of normalized counts",
      y = "log2 fold change", 
      subtitle = sprintf(
        "up=%s; down=%s",
        nrow(res_dt[padj<padj_thr & log2FoldChange>0]),
        nrow(res_dt[padj<padj_thr & log2FoldChange<0])
      )
    ) +
    theme(
      legend.position = "bottom", 
      plot.title = element_text(size = 20),
      plot.subtitle = element_text(size = 18)
    )
  if (title!="")
    gp <- gp + labs(title = title)
  gp
}
```

Contrasts

```{r message=FALSE, warning=FALSE, fig.width=8, fig.height=9}
contrast <- c("condition","positive","negative")
res_pos <- results(dds_cond, contrast = contrast)
res_lfc_pos <- lfcShrink(dds_cond, contrast = contrast, type="ashr")
gp_pos <- ggplotMA(
  res_lfc_pos, 
  lims_fc=c(-3,3), lims_mean=c(NA,1e3),
  title=sprintf("%s vs %s",contrast[2],contrast[3])
)

contrast <- c("group", "Foxpositive", "Foxnegative")
res_fox <- results(dds_conl, contrast = contrast)
res_lfc_fox <- lfcShrink(dds_conl, contrast = contrast, type="ashr")
contrast <- str_replace_all(contrast,c("positive"=" positive","negative"=" negative"))
gp_fox <- ggplotMA(
  res_lfc_fox, 
  lims_fc=c(-3,3), lims_mean=c(NA,1e3),
  title=sprintf("%s vs %s",contrast[2],contrast[3])
)

contrast <- c("group", "Elavpositive", "Elavnegative")
res_elav <- results(dds_conl, contrast = contrast)
res_lfc_elav <- lfcShrink(dds_conl, contrast = contrast, type="ashr")
contrast <- str_replace_all(contrast,c("positive"=" positive","negative"=" negative"))
gp_elav <- ggplotMA(
  res_lfc_elav, 
  lims_fc=c(-3,3), lims_mean=c(NA,1e3),
  title=sprintf("%s vs %s",contrast[2],contrast[3])
)

contrast <- c("group", "Ncolpositive", "Ncolnegative")
res_ncol <- results(dds_conl, contrast = contrast)
res_lfc_ncol <- lfcShrink(dds_conl, contrast = contrast, type="ashr")
contrast <- str_replace_all(contrast,c("positive"=" positive","negative"=" negative"))
gp_ncol <- ggplotMA(
  res_lfc_ncol, 
  lims_fc=c(-3,3), lims_mean=c(NA,1e3),
  title=sprintf("%s vs %s",contrast[2],contrast[3])
)

gp_pch <- ((gp_pos + gp_fox) / (gp_elav + gp_ncol)) + 
  plot_layout(guides = "collect") & theme(legend.position = "bottom")
gp_pch
```

```{r include=FALSE, eval=TRUE}
pdf(file.path(fig_dir, "MA_plots.pdf"), width=8, height=9)
gp_pch
dev.off()
```

## Motif discovery

Save per-group foreground and background peaks

```{r eval=FALSE, include=FALSE}
dir.create(file.path(hom_dir, "peaks"))
dir.create(file.path(hom_dir, "results"))
clusters_bed <- fread(file.path(res_dir, "consensusSeekeR-peaks-clusters.bed"))
setnames(clusters_bed, c("seqnames","start","end","name","score","strand","cluster"))
clusters_bed[,cluster:=factor(cluster, levels=paste0("C",seq_along(unique(cluster))))]
for (ci in levels(clusters_bed$cluster)) {
  fg <- clusters_bed[cluster==ci]
  bg <- clusters_bed[cluster!=ci]
  fwrite(fg, file.path(hom_dir, "peaks",sprintf("peaks-%s-fg.bed",ci)), col.names=FALSE, sep="\t")
  fwrite(bg, file.path(hom_dir, "peaks",sprintf("peaks-%s-bg.bed",ci)), col.names=FALSE, sep="\t")
}
```

```{r}
dir.create(file.path(hom_dir, "peaks"))
dir.create(file.path(hom_dir, "results"))
clusters_bed <- fread(file.path(res_dir, "consensusSeekeR-peaks-clusters.bed"))
setnames(clusters_bed, c("seqnames","start","end","name","score","strand","cluster","group"))
clusters_bed[,group:=factor(group, levels=paste0("G",seq_along(unique(group))))]
for (ci in levels(clusters_bed$group)) {
    fg <- clusters_bed[group==ci]
    bg <- clusters_bed[group!=ci]
    fwrite(fg, file.path(hom_dir, "peaks",sprintf("peaks-%s-fg.bed",ci)), col.names=FALSE, sep="\t")
    fwrite(bg, file.path(hom_dir, "peaks",sprintf("peaks-%s-bg.bed",ci)), col.names=FALSE, sep="\t")
}
```

De novo and known motifs in differentially accessible peaks

```{bash eval=FALSE, include=FALSE}
findMotifs(){
	genome="genome/Nvec_vc1.1_gDNA.fasta"
	homdir="ATACSEQ/nucleosome_free_regions/homer"
	bedfg=${homdir}"/peaks/peaks-C"${1}"-fg.bed"
	bedbg=${homdir}"/peaks/peaks-C"${1}"-bg.bed"
	outdir=$homdir"/results/${1}-Homer"
	echo ""
	echo "Starting HOMER analysis for" $1
	echo "using the intervals in" $bedfg
	echo "Output will be saved to" $outdir
	findMotifsGenome.pl $bedfg $genome $outdir -size 250 -len 6,8,10,12 -bg $bedbg 
	echo ""
	echo "Finished de novo analysis for module" $1
}

for cluster in {1..15}
do
  findMotifs "$cluster" &
done
wait
echo "Done."

```

```{bash eval=FALSE}

findMotifs(){
    genome="genome/Nvec_vc1.1_gDNA.fasta"
    homdir="ATACSEQ/nucleosome_free_regions/homer"
    bedfg=${homdir}"/peaks/peaks-G"${1}"-fg.bed"
    bedbg=${homdir}"/peaks/peaks-G"${1}"-bg.bed"
    outdir=$homdir"/results/G${1}-Homer"
    echo ""
    echo "Starting HOMER analysis for" $1
    echo "using the intervals in" $bedfg
    echo "Output will be saved to" $outdir
    findMotifsGenome.pl $bedfg $genome $outdir -size 250 -len 6,8,10,12 -bg $bedbg 
    echo ""
    echo "Finished de novo analysis for module" $1
}

for cluster in {1..9}
do
findMotifs "$cluster" &
    done
wait
echo "Done."

```

Parse de novo Homer results

```{bash eval=FALSE}
dir="./ATACSEQ/nucleosome_free_regions/homer/results/"
modules=$( find ${dir} -maxdepth 2 -iname "*-Homer" -printf "%f\n" )
for i in $modules
do 
  less ${dir}/${i}/homerMotifs.all.motifs | grep ">" > tmp.txt
  awk -v m="$M" 'BEGIN {FS="\t"} {OFS="\t"} {print m, $0}' tmp.txt >> ${dir}/${i}/homerResults.txt
done
```

Parse all Homer results

```{r eval=FALSE}
clusters_bed <- fread(file.path(res_dir, "consensusSeekeR-peaks-clusters.bed"))
setnames(clusters_bed, c("seqnames","start","end","name","score","strand","cluster","group"))
clusters_bed[,group:=factor(group, levels=paste0("G",seq_along(unique(group))))]

ParseHomerDenovo <- function(fn, eta=1) {
  dt <- fread(fn, sep="\t", header=FALSE)[,-1]
  setnames(dt,c("consensus","name","logodds_threshold","logpval","0","occurence","stats"))
  dt[,consensus:=stringr::str_remove(consensus,">")]
  dt[,c("fg","bg","pval"):=tstrsplit(occurence,",")]
  dt_occurence <- dt[,lapply(.SD,stringr::str_remove,pattern="[TBP]:"),.SDcols=c("fg","bg","pval")]
  dt_perc <- dt_occurence[,lapply(.SD,function(x) as.numeric(stringr::str_extract(x,"(?<=\\()\\d+\\.*\\d+"))/100),.SDcols=c("fg","bg")]
  setnames(dt_perc,c("fg","bg"),c("fg_perc","bg_perc"))
  dt_counts <- dt_occurence[,lapply(.SD,function(x) as.numeric(stringr::str_extract(x,"\\d+\\.*\\d*"))),.SDcols=c("fg","bg")]
  setnames(dt_counts,c("fg","bg"),c("fg_count","bg_count"))
  dt_occurence[,c("fg","bg"):=NULL]
  dt_occurence[,pval:=as.numeric(pval)]
  dt[,c("fg","bg","pval","occurence"):=NULL]
  dt <- cbind(dt,dt_perc,dt_counts,dt_occurence)
  dt$qval <- p.adjust(dt$pval, method = "BH")
  dt[,fc:=(fg_count+eta)/(bg_count+eta)]
  dt[,.(name,consensus,fc,pval,logpval,qval,fg_count,fg_perc,bg_count,bg_perc)]
}

ParseHomerKnown <- function(fn, eta=1) {
  dt <- fread(fn)
  setnames(dt, c("name","consensus","pval","logpval","qval","fg_count","fg_perc","bg_count","bg_perc"))
  dt[,fg_perc:=as.numeric(stringr::str_remove(fg_perc,"\\%"))/100]
  dt[,bg_perc:=as.numeric(stringr::str_remove(bg_perc,"\\%"))/100]
  dt[,fc:=(fg_count+eta)/(bg_count+eta)]
  dt[,.(name,consensus,fc,pval,logpval,qval,fg_count,fg_perc,bg_count,bg_perc)]
}

hm_list <- lapply(levels(clusters_bed$group), function(ci) {
  dn_fn <- file.path(hom_dir,"results",sprintf("%s-Homer",ci),"homerResults.txt")
  dn_dt <- ParseHomerDenovo(dn_fn)
  kn_fn <- file.path(hom_dir,"results",sprintf("%s-Homer",ci),"knownResults.txt")
  kn_dt <- ParseHomerKnown(kn_fn)
  hm_dt <- rbindlist(list(denovo=dn_dt, known=kn_dt), idcol="set")
  hm_dt
})
names(hm_list) <- levels(clusters_bed$group)
hm_dt <- rbindlist(hm_list, idcol = "group")
fwrite(hm_dt, file.path(hom_dir, "results", "allResuls.txt"), sep="\t", col.names = TRUE)
```

Motif enrichment

```{r}
dt <- fread(file.path(hom_dir, "results", "allResuls.txt"))

HomerMotifsHeatmap <- function(dt) {
  dat_qv <- dcast.data.table(unique(dt[,.(name,group,qval)]), name~group, value.var = "qval")
  mat_qv <- data.matrix(dat_qv)[,-1]
  mat_qv[is.na(mat_qv)] <- 1
  rownames(mat_qv) <- dat_qv$name
  
  dat_fc <- dcast.data.table(unique(dt[,.(name,group,fc)]), name~group, value.var = "fc")
  mat_fc <- data.matrix(dat_fc)[,-1]
  mat_fc[is.na(mat_fc)] <- 0
  rownames(mat_fc) <- dat_fc$name
  
  plot_mt <- (mat_fc+10)/apply(mat_fc+10,1,median) # row normalize to bring motifs to same range
  plot_mt <- log2(plot_mt)

  # center at 0
  plot_min <- quantile(abs(range(plot_mt)),0.75)
  plot_mt <- pmin(pmax(plot_mt,-plot_min),plot_min) 
  
  # heatmap colors
  col_vec <- colorRampPalette(RColorBrewer::brewer.pal(11,'PiYG'))(1000)
  col_fun <- circlize::colorRamp2(seq(-plot_min, plot_min, length.out = length(col_vec)), col_vec)
  

  ComplexHeatmap::Heatmap(
    t(plot_mt[,-9]), col=col_fun,
    cluster_rows = FALSE, cluster_columns = TRUE, 
    show_column_names = FALSE
  )
}
```

## Footprinting

Merge replicates per condition

```{bash eval=FALSE}
bam_dir="ATACSEQ/nucleosome_free_regions/bam/"
nth=18

for line in Fox Elav Ncol
do
  for cond in pos neg
  do
    name=${line}_${cond}
    echo ${name}
    bams=$( echo ${bam_dir}/${name}*bam )
    samtools merge -@ ${nth} ${bam_dir}/${name}.ncfree.bam ${bams}
    samtools sort -@ ${nth} -o ${bam_dir}/${name}.ncfree.sorted.bam ${bam_dir}/${name}.ncfree.bam
    rm ${bam_dir}/${name}.ncfree.bam
    samtools index -@ ${nth} ${bam_dir}/${name}.ncfree.sorted.bam
  done
done
```

Footprint score calculation for consensus peaks

```{bash eval=FALSE}
conda activate TOBIAS_ENV
bam_dir="ATACSEQ/nucleosome_free_regions/bam/"
out_dir="ATACSEQ/nucleosome_free_regions/footprint/"
mkdir ${out_dir}
peaks="ATACSEQ/nucleosome_free_regions/consensus_peaks/consensusSeekeR-peaks.bed"
genome="genome/Nvec_vc1.1_gDNA.fasta"
nth=12

for line in Fox Elav Ncol
do
  for cond in pos neg
  do
    name=${line}_${cond}
    
    echo $(date) "- Starting ATACorrect for" ${name}
    TOBIAS ATACorrect \
      --bam ${bam_dir}/${name}.ncfree.sorted.bam \
      --genome ${genome} \
      --peaks ${peaks} \
      --prefix ${name} \
      --outdir ${out_dir}/ATACorrect \
      --cores ${nth}
    
    echo $(date) "- Starting FootprintScores"
    TOBIAS FootprintScores \
      --signal ${out_dir}/ATACorrect/${name}_corrected.bw \
      --regions ${peaks} \
      --fp-min 10 --fp-max 50 \
      --output ${out_dir}/${name}_footprints.bw \
      --cores ${nth}
    
  done
done

```
