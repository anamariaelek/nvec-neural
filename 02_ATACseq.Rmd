---
title: "ATACseq"
output:
  html_document:
    theme: cosmo
    self_contained: true
    toc: true
    toc_float: true
    toc-location: left
editor: visual
---

## Setup

Load packages

```{r warning=FALSE, message=FALSE, results=FALSE}
library(data.table)
library(stringr)
library(ggplot2)
theme_py <- theme_light() + theme(
  panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(),
  panel.border = element_rect(colour = "black", fill = NA),
  text = element_text(size = 20),
  strip.placement = "outside",
  strip.text = element_text(size=20, color = "black"),
  strip.background = element_rect(fill = "white")
)
theme_set(theme_py)
library(patchwork)
library(ggrepel)
library(ComplexHeatmap)
library(DESeq2)
library(consensusSeekeR)
library(BSgenome.jaNemVect1.1.DToL.Assembly)
library(GenomicRanges)
library(parallel)
library(universalmotif)
library(monaLisa)
library(rtracklayer)
library(ComplexUpset)
source("../motif-analysis/mta_downstream_functions.R")
source("scripts/functions.R")
```

Directories and colors

```{r}
dat_dir <- "ATACSEQ/nucleosome_free_regions/"
pks_dir <- file.path(dat_dir, "macs2_peaks")
cns_dir <- file.path(dat_dir, "consensus_peaks")
hom_dir <- file.path(dat_dir, "homer")
ftp_dir <- file.path(dat_dir, "footprint")
bind_dir <- file.path(dat_dir, "footprint", "BINDetect")
res_dir <- file.path(dat_dir, "results")
fig_dir <- file.path(dat_dir, "plots")
for (newdir in c(cns_dir, hom_dir, res_dir, fig_dir))
  dir.create(newdir, showWarnings = FALSE)

# colors
condition_cols <- c("positive" = "blue", "negative" = "red")
line_cols <- c("Elav" = "#ff7f00", "Fox" = "#984ea3", "Ncol" = "#4daf4a")
line_cond_cols <- c(
  "Elav_pos" = "#ff7f00", "Fox_pos" = "#984ea3", "Ncol_pos" = "#4daf4a",
  "Elav_neg" = "#ebbd8f", "Fox_neg" = "#d18adb", "Ncol_neg" = "#90d18e"
)
```

Gene annotations

```{r}
# markers
marks_gold <- fread(
  file.path("annotation", "golden-marks-231124.tsv"),
  fill = TRUE, sep = "\t", header = FALSE
)#[, c(2:1)]
setnames(marks_gold, c("gene", "name", "cts"))
marks_gold_v <- structure(marks_gold$name, names = marks_gold$gene)

# annotation
tfs_annt <- fread(
  file.path("annotation", "tfs.Nvec.tsv"),
  header = TRUE
)[, .SD[1], gene]
setnames(tfs_annt, c("gene", "name", "pfam"))

gene_annt <- fread(
  file.path("annotation", "Nvec_annotation_v3_2020-10-23_DToL_names"),
  select = 1:3
)
setnames(gene_annt, c("gene", "pfam", "name"))

gene_ann <- rbindlist(list(
  gene_annt[!gene %in% tfs_annt$gene],
  tfs_annt
), use.names = TRUE)
gene_ann[gene %in% marks_gold$gene, name := marks_gold_v[gene]]

# motif to tf assignment
dc <- fread(file.path(
  "annotation",
  "assignment-archetype-motif-gene.tsv.gz"
))[, .(gene, archetype_name)]
dc[, motif := str_extract(archetype_name, "ARCH\\d+")]
dc[, archetype_name := NULL]
dc_tf <- merge.data.table(
  dc, tfs_annt, by = "gene", all.x = TRUE
)
dc_tf[gene %in% names(marks_gold_v), name := marks_gold_v[gene]]

```

## Peaks counts

Find consensus set of peaks

```{r eval=FALSE}
require(consensusSeekeR)
require(BSgenome.jaNemVect1.1.DToL.Assembly)
require(parallel)

# load peaks
pks_files <- list.files(
  pks_dir,
  pattern = "narrowPeak",
  recursive = FALSE,
  full.names = TRUE
)
names(pks_files) <- str_remove(
  basename(pks_files),
  ".mLb.clN.ncfree_peaks.narrowPeak"
)
nP_list <- lapply(names(pks_files), function(x) {
    nP <- readNarrowPeakFile(
      pks_files[x],
      extractRegions = TRUE,
      extractPeaks = TRUE
    )
    names(nP$narrowPeak) <- rep(x, length(nP$narrowPeak))
    names(nP$peak) <- rep(x, length(nP$peak))
    nP
})
regions <- GenomicRanges::GRangesList(lapply(nP_list, function(x) x$narrowPeak))
peaks <- GenomicRanges::GRangesList(lapply(nP_list, function(x) x$peak))
names(regions) <- names(pks_files)
names(peaks) <- names(pks_files)

# get consensus
chrList <- Seqinfo(
    seqnames = seqnames(BSgenome.jaNemVect1.1.DToL.Assembly),
    seqlengths = seqlengths(BSgenome.jaNemVect1.1.DToL.Assembly),
    isCircular = c(
      rep(FALSE, length(seqnames(BSgenome.jaNemVect1.1.DToL.Assembly)) - 1),
      TRUE
    ),
    genome = "jaNemVect1.1"
)
message(Sys.time(), " Started calculating consensus")
ur <- unlist(regions)
up <- unlist(peaks)

results <- findConsensusPeakRegions(
    narrowPeaks = ur,
    peaks = up,
    chrInfo = chrList,
    extendingSize = 250,
    expandToFitPeakRegion = FALSE,
    shrinkToFitPeakRegion = FALSE,
    minNbrExp = 2,
    nbrThreads = detectCores() - 1
)
message(Sys.time(), " Done calculating consensus")
saveRDS(results, file.path(cns_dir, "consensusSeekeR-results.RDS"))
saveRDS(results, file.path(cns_dir, "consensusSeekeR-results.RDS"))

# resize peaks
pks_cns <- results$consensusRanges
pks_mid <- start(pks_cns) + (end(pks_cns) - start(pks_cns)) / 2
ranges(pks_cns) <- IRanges(pks_mid, width = 0)
pks_scl <- promoters(pks_cns, upstream = 125, downstream = 125)

# trim out-of-bound peaks
seqlengths(pks_scl) <- seqlengths(
  BSgenome.jaNemVect1.1.DToL.Assembly
)[names(seqlengths(pks_scl))]
pks_scl <- trim(pks_scl)

# save bed file
pks_bed <- as.data.table(pks_scl)
pks_bed[, name := paste0("peak", seq_len(.N))]
pks_bed[, width := NULL][, score := "."]
setcolorder(pks_bed, c("seqnames", "start", "end", "name", "score", "strand"))
fwrite(
  pks_bed,
  file.path(cns_dir, "consensusSeekeR-peaks.bed"),
  sep = "\t",
  col.names = FALSE
)
```

Get scores for consensus peaks in all samples.

```{r include=FALSE, eval=FALSE}
# load consensus peaks
pks_bed <- fread(file.path(cns_dir,"consensusSeekeR-peaks.bed"))
setnames(pks_bed, c("seqnames", "start", "end", "name", "score", "strand"))
pks_grn <- makeGRangesFromDataFrame(pks_bed, keep.extra.columns = TRUE)

# get counts in consensus peaks
bws_files <- list.files(
  file.path(dat_dir, "bigwig"),
  pattern = ".bigwig",
  full.names = TRUE
)
bws_names <- str_remove(basename(bws_files), ".mLb.clN.ncfree.bigwig")
bws_files <- list.files(
  file.path(dat_dir, "bigwig"),
  pattern = ".bigwig",
  full.names = TRUE
)
bws_names <- str_remove(basename(bws_files), ".mLb.clN.ncfree.bigwig")
names(bws_files) <- bws_names
bws_signal <- rbindlist(lapply(bws_names, function(smp){
  as.data.table(import(bws_files[smp]))[, sample := smp][]
  as.data.table(import(bws_files[smp]))[, sample := smp][]
}))

# overlap signal with consensus peaks
pks_list <- lapply(bws_names, function(smp) {
  bw_dt <- bws_signal[sample == smp]
  bw_gr <- makeGRangesFromDataFrame(bw_dt, keep.extra.columns = TRUE)
  # ovl
  ovl <- findOverlaps(query = bw_gr, subject = pks_grn)
  ps_dt <- as.data.table(pks_grn[subjectHits(ovl)])
  scs <- mcols(bw_gr[queryHits(ovl)])$score
  ps_dt[,score := scs]
  # non ovl
  if (any(!pks_grn$name %in% ps_dt$name)) {
    message("Adding missing peks for ", smp)
    ps_dt <- rbindlist(list(
      ps_dt,
      as.data.table(pks_grn)[!name %in% ps_dt$name][,score:=0]
    ), use.names = TRUE)
  }
  ps_dt[, sample := smp][]
})
pks_dt <- rbindlist(pks_list)

# keep max signal in each peak
pks_dt[, score := as.numeric(score)]
pkt_dt <- pks_dt[order(name, -score)][, .SD[1], .(name,sample)]
pkt_dt[, seqnames := factor(seqnames, levels = levels(seqnames(pks_grn)))]
setorder(pkt_dt, seqnames, start, end)

# save bed file
pkt_dt[, width := NULL]
setcolorder(
  pkt_dt,
  c("seqnames", "start", "end", "name", "score", "strand", "sample")
)
fwrite(pkt_dt, file.path(
  cns_dir, "consensusSeekeR-peaks-samples.bed"
), sep = "\t", col.names = FALSE)
```

```{bash eval=FALSE}
nth=12
res="ATACSEQ/nucleosome_free_regions/consensus_peaks/consensusSeekeR-peaks-counts.tsv"
bed="ATACSEQ/nucleosome_free_regions/consensus_peaks/consensusSeekeR-peaks.bed"
bam=$( echo ATACSEQ/nucleosome_free_regions/bam/*R*bam )

cols=$( echo -e seqnames start end name score strand | column -t )
for b in $bam
do 
  echo $b
  name=$( basename $b)
  cols=$( echo -e ${cols} ${name} | column -t )
done

echo -e ${cols} > ${res%%tsv}txt
bedtools multicov -bams ${bam} -bed ${bed} > ${res}
```

Data for differential peaks analysis

```{r}
# load counts in peaks
pks_ct <- fread(
  file.path(cns_dir, "consensusSeekeR-peaks-counts.tsv"),
  header = FALSE
)
colnames <- readLines(
  file.path(cns_dir, "consensusSeekeR-peaks-counts.txt"),
  n = 1
)
colnames <- str_remove_all(colnames, ".mLb.clN.ncfree.sorted.bam")
colnames <- str_split(colnames, " ")[[1]]
colnames(pks_ct) <- colnames

# column data
col_dt <- data.table(sample = colnames(pks_ct)[7:28])
col_dt[, reporterline := str_extract(sample, "Elav|Fox|Ncol")]
col_dt[, reporterline := factor(reporterline, levels=c("Elav", "Fox", "Ncol"))]
col_dt[, condition := str_extract(sample, "pos|neg")]
col_dt[, condition := str_replace_all(
  condition,
  c("pos" = "positive", "neg" = "negative")
)]
col_dt[, condition := factor(condition, levels = c("negative", "positive"))]
col_dt[, group := paste(
  as.character(reporterline), as.character(condition), sep = ""
), by = seq_len(nrow(col_dt))]
col_dt[, group := factor(group)]
fwrite(col_dt, file.path(res_dir, "design.tsv"), sep = "\t")

col_df <- copy(col_dt)
class(col_df) <- "data.frame"
rownames(col_df) <- col_df$sample

# counts matrix
pks_mt <- as.matrix(pks_ct[, -c(1:6)])
rownames(pks_mt) <- pks_ct$name
pks_mt <- pks_mt[, rownames(col_df)]
write.table(
  pks_mt,
  file.path(res_dir, "mat.tsv"),
  sep = "\t",
  quote = FALSE
)

# DESeq2
require(DESeq2)
dds <- DESeqDataSetFromMatrix(
  countData = pks_mt,
  colData = col_df,
  design = ~ condition + reporterline
)
saveRDS(dds, file.path(res_dir, "dds.rds"))
```

Peaks counts distributions

```{r fig.width=8, fig.height=6, warning=FALSE, message=FALSE}
# normalized accessibility distribution
pks_dt <- as.data.table(pks_mt, keep.rownames = "peak")
pks_dt <- melt.data.table(
  pks_dt,
  id.vars = "peak",
  variable.name = "sample",
  value.name = "norm_counts"
)
pks_dt <- merge.data.table(pks_dt, col_dt, by = "sample")
setorder(pks_dt, peak, condition, reporterline)
pks_dt[, sample := factor(sample, levels = unique(pks_dt$sample))]

gp_acc <- ggplot(pks_dt, aes(sample, log10(norm_counts), fill = reporterline)) +
  geom_violin(scale = "width", alpha = 0.8, color = "black") +
  geom_boxplot(width = 0.5, outlier.shape = NA, alpha = 0.8, color = "black") +
  scale_fill_manual(values = line_cols, limits = force) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.01))) +
  labs(x = "samples", y = "peak\naccessibility") +
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
    legend.title = element_blank(), legend.position = "none"
  )

var_dt <- pks_dt[, .(var = var(norm_counts)), peak]
gp_var <- ggplot(var_dt, aes(log10(var))) +
  geom_density() +
  scale_x_continuous(limits = c(-4, NA)) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.01))) +
  labs(x = "log10(accessibility variance)")

gp_pch <- gp_acc / gp_var + plot_layout(heights = c(2, 1))
gp_pch
```

```{r include=FALSE, eval=TRUE}
pdf(file.path(fig_dir, "peaks_var_norm.pdf"), width = 8, height = 6)
gp_pch
dev.off()
```

Use normalized log-transformed accessibility data

```{r}
# normalize samples
dds <- readRDS(file.path(res_dir, "dds.rds"))
dds <- estimateSizeFactors(dds)
norm_mt <- counts(dds, normalized = TRUE)

# save
write.table(
  norm_mt,
  file.path(res_dir, "mat_norm.tsv"),
  sep = "\t",
  row.names = TRUE,
  quote = FALSE
)

# row normalize to bring peaks to same range
norm_mt <- (norm_mt + 10) / apply(norm_mt + 10, 1, median)
norm_mt <- log2(norm_mt)

# save
write.table(
  norm_mt,
  file.path(res_dir, "mat_norm_fc.tsv"),
  sep = "\t",
  row.names = TRUE,
  quote = FALSE
)
```

## PCA

PCA on all samples.

```{r fig.width=8, fig.height=10, warning=FALSE}
set.seed(1950)
pca_res <- prcomp(t(norm_mt), center = TRUE)

# variance explained
pca_var <- data.table(
  pct_var = round(((pca_res$sdev) ^ 2 / sum((pca_res$sdev) ^ 2)* 100), 2)
)
pca_var[,pct_cum:=cumsum(pct_var)]
pca_var[,PC:=factor(1:.N)]
gp_var <- ggplot(pca_var, aes(PC, pct_var)) +
  geom_bar(stat = "identity") +
  geom_line(aes(y = pct_cum, group = 1)) +
  geom_point(aes(y = pct_cum)) +
  scale_y_continuous(expand = expansion(0.01,0)) +
  labs(y = "% of variance\nexplained", x = "PC") +
  theme(panel.grid.major.y = element_line(size = 0.5))

pca_dt <- as.data.table(pca_res$x, keep.rownames = "sample")
pca_dt <- merge.data.table(col_dt, pca_dt, by="sample", sort=FALSE)
gp_bip <- ggplot(pca_dt, aes(PC1, PC2, fill=reporterline, shape=condition)) +
  geom_point(size = 5) +
  scale_fill_manual(values = line_cols) +
  scale_shape_manual(values = c("positive" = 21, "negative" = 24)) +
  guides(fill = guide_legend(override.aes=list(shape=21))) +
  geom_text_repel(aes(label = sample))

gp_pch <- gp_var / gp_bip
gp_pch
```

```{r include=FALSE, eval=TRUE}
pdf(file.path(fig_dir, "PCA_all.pdf"), width=8, height=10)
gp_pch
dev.off()
```

PCA per cell line

```{r fig.height=8, fig.width=7}
set.seed(1950)

gp_l <- lapply(names(line_cols), function(cl) {

  pca_res <- prcomp(t(norm_mt[,grep(cl,colnames(norm_mt))]), center = TRUE)

  # variance explained
  pca_var <- data.table(
    pct_var = round(((pca_res$sdev) ^ 2 / sum((pca_res$sdev) ^ 2)* 100), 2)
  )
  pca_var <- pca_var[-nrow(pca_var)]
  pca_var[,pct_cum:=cumsum(pct_var)]
  pca_var[,PC:=factor(1:.N - 1)]
  gp_var <- ggplot(pca_var, aes(PC, pct_var)) +
    geom_bar(stat = "identity") +
    geom_line(aes(y = pct_cum, group = 1)) +
    geom_point(aes(y = pct_cum)) +
    scale_y_continuous(expand = expansion(0.01,0)) +
    labs(y = "% of variance\nexplained", x = "PC") +
    theme(panel.grid.major.y = element_line(size = 0.5))
  
  # pca plot
  pca_dt <- as.data.table(pca_res$x, keep.rownames = "sample")
  pca_dt <- merge.data.table(col_dt, pca_dt, by="sample", sort=FALSE)
  gp_bip <- ggplot(pca_dt, aes(PC1, PC2, fill=condition, shape=condition)) +
    geom_point(size=5) +
    scale_shape_manual(values = c("positive" = 21, "negative" = 24)) +
    scale_fill_manual(values = condition_cols) +
    guides(fill = guide_legend(override.aes=list(shape=21))) +
    geom_text_repel(aes(label = sample))
  
  gp_var / gp_bip 

})
gp_l
```

```{r include=FALSE, eval=TRUE}
pdf(file.path(fig_dir, "PCA_reporter_lines.pdf"), width=7, height=8)
gp_l
dev.off()
```

## Marker peaks

Use normalized peak counts

```{r}
norm_mt <- read.table(
  file.path(res_dir, "mat_norm_fc.tsv"),
  header = TRUE
)
```

Identify marker peaks

```{r include=FALSE, eval=TRUE}
# peak markers by normalized accessibility
peaks_fc <- names(which(apply(norm_mt, 1, function(x) 
  sort(x,decreasing=TRUE)[1] >= 2
)))
peaks_vari <- names(which(
  apply(norm_mt, 1, function(x) var(x) > 1)
))
```

```{r include=TRUE, eval=TRUE}
# gene markers by high FC + significant DEseq2 LTR test 
dds <- readRDS(file.path(res_dir, "dds.rds"))
dds <- DESeq(dds, test="LRT", reduced=~1)
dds_res <- results(dds)
dds_qval <- dds_res$padj 
names(dds_qval) <- rownames(dds_res)
peaks_deseq <- names(which(dds_qval<1e-2))
peaks_high <- names(which(apply(
  norm_mt, 1, function(x) sort(x, decreasing = TRUE)[2] >= 1.8
)))
peaks_marks <- intersect(peaks_high, peaks_deseq)
length(peaks_marks)
```

Cluster peaks

```{r fig.width=10, fig.height=6}
set.seed(1950)

# determine k for kmeans
ks <- 1:30
tot_withinss <- sapply(ks,  function(k) {
  cl <- kmeans(norm_mt[peaks_marks,], k)
  cl$tot.withinss
})
elbow_dt <- data.table(k = ks, tot_withinss = tot_withinss)
elbow_gp <- ggplot(elbow_dt, aes(x = k, y = tot_withinss)) +
  geom_line() + geom_point()+
  scale_x_continuous(breaks = ks)
elbow_gp
```

```{r include=FALSE, eval=TRUE}
pdf(file.path(fig_dir, "kmeans_elbow.pdf"), width=8, height=6)
elbow_gp
dev.off()
```

Cluster peaks

```{r}
# kmeans
set.seed(1950)
k <- 19
cl <- kmeans(norm_mt[peaks_marks,], k)
peaks_order_list <- tapply(names(cl$cluster), cl$cluster, function(gs) {
  cor_peaks <- cor(t(norm_mt[gs,]))
  hclust_peaks <- hclust(as.dist(
    1 - cor(cor_peaks)),
    method = "ward.D2"
  )
  rownames(cor_peaks)[hclust_peaks$order]
})
names(peaks_order_list) <- unique(cl$cluster)
peaks_order_list <- peaks_order_list[as.character(seq_along(peaks_order_list))]

# cluster clusters
cluster_order <- hclust(dist(
  cor(t(cl$centers)), method = "euclidean"
), method = "ward.D2")$order
peaks_order_list <- peaks_order_list[as.character(cluster_order)]
peaks_order <- unname(unlist(peaks_order_list))
clusters_dt <- data.table(
  peak = peaks_order,
  clusters = as.character(rep(
    names(peaks_order_list),
    sapply(peaks_order_list, length)
  ))
)

# group clusters (manually)
clusters_dt[clusters %in% c(16), group :=1 ] # Elav
clusters_dt[clusters %in% c(5), group :=2 ] # Elav + Fox
clusters_dt[clusters %in% c(14,17), group := 3] # Fox
clusters_dt[clusters %in% c(6,11), group := 4] # Fox + Ncol
clusters_dt[clusters %in% c(9), group := 5]
clusters_dt[clusters %in% c(13,4), group := 6] # Elav + Ncol
clusters_dt[clusters %in% c(1,2,15,7,8,10,19,18), group := 7] # Ncol
clusters_dt[clusters %in% c(12), group := 8]
clusters_dt[clusters %in% c(3), group := 9]
setorder(clusters_dt, group)
peaks_order <- clusters_dt$peak

# add clusters info to peaks coordinates bed file
pks_bed <- fread(file.path(cns_dir, "consensusSeekeR-peaks.bed"))
setnames(pks_bed, c("V4"), c("peak"))
clusters_bed <- merge.data.table(
  pks_bed, clusters_dt,
  by = "peak",
  sort = FALSE
)
setcolorder(clusters_bed, c(colnames(pks_bed)))
clusters_bed[, clusters := paste0("C", clusters)]
clusters_bed[, group := paste0("G", group)]
fwrite(
  clusters_bed,
  file.path(res_dir, "consensusSeekeR-peaks-clusters.bed"),
  sep = "\t",
  col.names = FALSE
)
```

Heatmap of markers

```{r fig.height=10, fig.width=8, warning=FALSE, message=FALSE}
# order rows and columns
samples_order <- col_dt[order(condition,reporterline)]$sample
plot_mt <- norm_mt[peaks_order,samples_order]

# center at 0
plot_min <- quantile(abs(range(plot_mt)),0.75)
plot_min <- 5
plot_mt <- pmin(pmax(plot_mt,-plot_min),plot_min)

# heatmap colors
col_vec <- colorRampPalette(
  RColorBrewer::brewer.pal(11,'BrBG')
)(1000)
col_fun <- circlize::colorRamp2(
  seq(-plot_min, plot_min, length.out = length(col_vec)),
  col_vec
)

# color annotaitons
col_ann <- HeatmapAnnotation(
    which = "column", border = TRUE,
    "reporterline" = as.character(
      col_dt[match(colnames(plot_mt),sample)]$reporterline
    ),
    "condition" = as.character(
      col_dt[match(colnames(plot_mt),sample)]$condition
    ), 
    col = list(
      "reporterline" = line_cols,
      "condition" = condition_cols
    )
)

# # peak module annotations (clusters)
# clann <- clusters_dt[match(rownames(plot_mt),peak)]$clusters
# clann_lab <- unique(clusters_dt[match(rownames(plot_mt),peak)]$clusters)
# clann <- factor(clann, levels=clann_lab)
# module_ann <- HeatmapAnnotation(
#     which = "row", border = TRUE,
#     "cluster" = anno_block(
#       labels = clann_lab,
#       gp = gpar(col=NA)
#     )
# )
# row_split <- clann

# peak module annotations (manually groupped clusters)
grann <- clusters_dt[match(rownames(plot_mt),peak)]$group
grann_lab <- unique(clusters_dt[match(rownames(plot_mt),peak)]$group)
grann <- factor(grann, levels=grann_lab)
module_ann <- HeatmapAnnotation(
    which = "row", border = TRUE,
    "group" = anno_block(
      labels = grann_lab,
      gp = gpar(col=NA)
    )
)
row_split <- grann

# peaks annotations
row_labels_marks_ids <- match(
  clusters_dt[,.SD[1],clusters]$peak,
  rownames(plot_mt)
)
row_labels_marks <- clusters_dt[,.SD[1], clusters]$clusters
mark_ann <- HeatmapAnnotation(
  which = "row",
  marker = anno_mark(at = row_labels_marks_ids, labels = row_labels_marks),
  show_legend = FALSE
)
mark_ann <- HeatmapAnnotation(
    which = "row", border = TRUE,
    "padj<0.05" = rownames(plot_mt) %in% peaks_deseq,
    "var>1" = rownames(plot_mt) %in% peaks_vari,
    "FC>2" = rownames(plot_mt) %in% peaks_fc,
    col = list(
      "padj<0.05" = c("TRUE" = "#e6ab02", "FALSE"="#d9d9d9"),
      "var>1" = c("TRUE" = "#3690c0", "FALSE"="#d9d9d9"),
      "FC>2" = c("TRUE" = "#e7298a", "FALSE"="#d9d9d9")
    )
)

# heatmap
hm <- Heatmap(
  plot_mt, name = "normalized\naccessibility",
  col = col_fun,
  cluster_rows = FALSE, cluster_columns = FALSE,
  show_row_names = FALSE, show_column_names = TRUE,
  row_title = "peaks", 
  row_split = row_split, 
  cluster_row_slices = FALSE,
  top_annotation = col_ann,  
  left_annotation = module_ann, right_annotation = mark_ann,
  border = TRUE
)
hm
```

```{r include=FALSE, eval=TRUE}
pdf(file.path(fig_dir, "peaks_heatmap_group.pdf"), width=8, height=10)
draw(hm)
dev.off()
```

## Peak to gene assignment

Load data

```{r}
# peaks
peaks <- fread(file.path(cns_dir, "consensusSeekeR-peaks.bed"))
setnames(peaks, c("seqnames", "start", "end", "name", "score", "strand"))
peaks_gr <- makeGRangesFromDataFrame(peaks, keep.extra.columns = TRUE)

# genes
genes_gr <- rtracklayer::import(
  "annotation/Nvec_v4_merged_annotation_sort.gtf",
  "gtf"
)
genes_gr <- genes_gr[genes_gr$type == "transcript"]
genes_gr$name <- genes_gr$transcript_id

# non-expressed genes to remove
counts <- read.table(
  "RNASEQ_QUANTIFICATION/raw_counts_rnaseq.tsv",
  header = TRUE,
  row.names = 1
)
exclude_genes <- names(which(
  apply(counts, 1, function(x) sum(x) < 10)
))
length(exclude_genes) # 437
```

Assign peaks to genes

```{r eval=FALSE}
# assign
assign <- mta_match_peaks_to_genes(
  gff_object = genes_gr,
  peak_object = peaks_gr,
  index_object = "genome/Nvec_vc1.1_gDNA.fasta.fai",
  list_genes = NULL,
  feature_to_match = "transcript",
  feature_field = "name",
  exclude_genes = NULL,
  max_tss_dist = 10000,
  min_overlap = 0,
  max_gap = 1,
  promoter_upstream = 200,
  promoter_downstream = 50,
  promoter_object = NULL
)
setDT(assign)
setnames(assign, "chr", "seqnames")
assign[, seqnames := factor(seqnames, levels = unique(peaks$seqnames))]
setorder(assign, seqnames, start, end)

# save
fwrite(
  assign,
  file.path(res_dir, "consensusSeekeR-peaks-gene-assignment.tsv"),
  sep = "\t",
  col.names = TRUE
)
```

Inspect peak assignment results

```{r fig.width=10, fig.height=6}
assign <- fread(file.path(res_dir, "consensusSeekeR-peaks-gene-assignment.tsv"))

max_assign_peaks_per_gene <- unique(
  assign[, .(peak, gene)][!is.na(gene)]
)[, .N, gene]
gb1 <- ggplot(max_assign_peaks_per_gene, aes(N)) +
  geom_bar() +
  labs(x = "peaks per gene", y = "genes") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.01))) +
  scale_x_continuous(
    breaks = c(1, seq(5, max(max_assign_peaks_per_gene$N), 5))
  )

max_assign_gene_per_peak <- unique(
  assign[, .(peak, gene)][!is.na(gene)]
)[, .N, peak]
gb2 <- ggplot(max_assign_gene_per_peak, aes(N)) +
  geom_bar() +
  labs(x = "genes per peak", y = "peaks") +
  scale_y_continuous(
    expand = expansion(mult = c(0, 0.01)),
    labels = scales::label_number(scale = 0.001, suffix = "K")
  ) +
  scale_x_continuous(breaks = seq(1, max(max_assign_peaks_per_gene$N)))

gb1 + gb2
```

```{r include=FALSE, eval=TRUE}
pdf(
  file.path(fig_dir, "peaks_per_gene_10k.pdf"),
  width = 7, height = 3
)
gb1 + gb2
dev.off()
```

Calculate gene accessibility scores as weighted sum of normalized peak scores assigned to genes.

```{r eval=FALSE}
assign <- fread(file.path(res_dir, "consensusSeekeR-peaks-gene-assignment.tsv"))
setnames(assign, "seqnames", "chr")

genes_gff <- genes_gr#[!genes_gr$name %in% exclude_genes]
genes_gff$symbol <- genes_gff$name

peaks_mt <- read.table(file.path(res_dir, "mat_norm.tsv"))

# cells_groups <- fread(file.path(res_dir, "design.tsv"))[, .(sample, group)]
# setnames(cells_groups, "sample", "cell")

gscore <- mta_gene_scores(
  genes_peaks_table = assign,
  gff_object = genes_gff,
  peak_object = peaks_gr,
  peaks_mat = peaks_mt
)

saveRDS(gscore, file.path(res_dir, "consensusSeekeR-gene-scores.rds"))
write.table(
  gscore$genes_scores_matrix,
  file.path(res_dir, "consensusSeekeR-gene-scores.tsv"),
  sep = "\t",
  col.names = TRUE
)
```

Use normalized gene scores

```{r}
# load gene scores
norm_mt <- read.table(
  file.path(res_dir, "consensusSeekeR-gene-scores.tsv"),
  header = TRUE
)
# row normalize to bring genes to same range
norm_mt <- (norm_mt + 10) / apply(norm_mt + 10, 1, median) 
norm_mt <- log2(norm_mt)

# save for shiny app
saveRDS(norm_mt, file.path(res_dir, "gene_scores.rds"))
```

```{r include=TRUE, eval=TRUE}
con_mt <- read.table(
  file.path(res_dir, "consensusSeekeR-gene-scores-raw.tsv"),
)

# gene markers by high FC + significant DEseq2 LTR test
dds <- DESeqDataSetFromMatrix(
  countData = con_mt,
  colData = col_df,
  design = ~ condition + reporterline + condition:reporterline
)
dds <- DESeq(dds, test = "LRT", reduced = ~ 1)
dds_res <- results(dds)
dds_qval <- dds_res$padj
names(dds_qval) <- rownames(dds_res)
genes_deseq <- names(which(dds_qval < 1e-2))

genes_high <- names(which(apply(norm_mt, 1, function (x)
  sort(x, decreasing = TRUE)[1] > 1.8
)))

gene_marks <- intersect(genes_high, genes_deseq)

# inclusde golden markers
marks_gold <- fread(
  file.path("annotation", "golden-marks-230116.tsv"),
  fill = TRUE
)[, 1:2]
setnames(marks_gold, c("gene", "name"))
marks_gold[, name := str_remove(name, "^Nv")]
gene_marks <- unique(c(gene_marks, marks_gold[gene %in% genes_deseq]$gene))
```

Select number of clusters for genes

```{r fig.width=10, fig.height=6}
set.seed(1950)

# determine k for kmeans
ks <- 1:30
tot_withinss <- sapply(ks,  function(k) {
  cl <- kmeans(norm_mt[gene_marks, ], k)
  cl$tot.withinss
})
elbow_dt <- data.table(k = ks, tot_withinss = tot_withinss)
elbow_gp <- ggplot(elbow_dt, aes(x = k, y = tot_withinss)) +
  geom_line() + geom_point() +
  scale_x_continuous(breaks = ks) + 
  theme(panel.grid.major = element_line(size = 0.5))
elbow_gp
```

```{r include=FALSE, eval=TRUE}
pdf(file.path(fig_dir, "kmeans_genes_elbow.pdf"), width=8, height=6)
elbow_gp
dev.off()
```

Cluster genes

```{r}
set.seed(1950)

# kmeans
k <- 18
cl <- kmeans(norm_mt[gene_marks, ], k)
gene_order_list <- tapply(names(cl$cluster), cl$cluster, function(gs) {
  cor_genes <- cor(t(norm_mt[gs,]))
  hclust_genes <- hclust(as.dist(1 - cor(cor_genes)), method = "ward.D2")
  rownames(cor_genes)[hclust_genes$order]
})
names(gene_order_list) <- unique(cl$cluster)
gene_order_list <- gene_order_list[as.character(seq_along(gene_order_list))]

# cluster clusters
cluster_order <- hclust(
  dist(cor(t(cl$centers)),
  method = "euclidean"),
  method = "ward.D2"
)$order
gene_order_list <- gene_order_list[as.character(cluster_order)]
gene_order <- unname(unlist(gene_order_list[cluster_order]))
clusters_dt <- data.table(
  gene = unlist(gene_order_list),
  clusters = as.character(
    rep(names(gene_order_list), sapply(gene_order_list, length))
  )
)

# group clusters (manually)
clusters_dt[clusters %in% c(8, 15), group := 1] # Elav
clusters_dt[clusters %in% c(1, 4), group := 2] # Elav + Fox
clusters_dt[clusters %in% c(16, 2), group := 3] # Fox
clusters_dt[clusters %in% c(3), group := 4] # Fox + Ncol
clusters_dt[clusters %in% c(13), group := 5] # Fox + Ncol + Elav
clusters_dt[clusters %in% c(17, 5), group := 6] # Elav + Ncol
clusters_dt[clusters %in% c(7, 14, 6, 10, 11, 9), group := 7] # Ncol
clusters_dt[clusters %in% c(12), group := 8]
clusters_dt[clusters %in% c(18), group := 9]
setorder(clusters_dt, group)
gene_order <- clusters_dt$gene

# save
fwrite(
  clusters_dt,
  file.path(res_dir, "genes_clusters.tsv"),
  sep = "\t"
)
```

Heatmap of markers

```{r fig.height=10, fig.width=8, warning=FALSE, message=FALSE}
# order rows and columns
col_dt <- fread(file.path(res_dir, "design.tsv"))
samples_order <- col_dt[order(condition, reporterline)]$sample
plot_mt <- norm_mt[gene_order, samples_order]

# center at 0
plot_min <- quantile(abs(range(plot_mt)), 0.75)
plot_min <- 4
plot_mt <- pmin(pmax(plot_mt, -plot_min), plot_min)

# heatmap colors
col_vec <- colorRampPalette(RColorBrewer::brewer.pal(11, 'BrBG'))(1000)
col_fun <- circlize::colorRamp2(
  seq(-plot_min, plot_min, length.out = length(col_vec)),
  col_vec
)

# color annotations
col_ann <- HeatmapAnnotation(
    which = "column",
    border = TRUE,
    "reporterline" = as.character(
      col_dt[match(colnames(plot_mt), sample)]$reporterline
    ),
    "condition" = as.character(
      col_dt[match(colnames(plot_mt), sample)]$condition
    ),
    col = list("reporterline" = line_cols, "condition" = condition_cols)
)

# gene module annotations
clann <- clusters_dt[match(rownames(plot_mt), gene)]$clusters
clann_lab <- unique(clusters_dt[match(rownames(plot_mt), gene)]$clusters)
clann <- factor(clann, levels = clann_lab)
module_ann <- HeatmapAnnotation(
    which = "row", border = TRUE,
    "cluster" = anno_block(
      labels = clann_lab,
      gp = gpar(col = NA)
    )
)
row_split <- clann

# gene module annotations (manual groups)
grann <- clusters_dt[match(rownames(plot_mt), gene)]$group
grann_lab <- unique(clusters_dt[match(rownames(plot_mt), gene)]$group)
grann <- factor(grann, levels = grann_lab)
module_ann <- HeatmapAnnotation(
    which = "row", border = TRUE,
    "group" = anno_block(
      labels = grann_lab,
      gp = gpar(col = NA)
    )
)
row_split <- grann
# gene module annotations (manual groups)
grann <- clusters_dt[match(rownames(plot_mt), gene)]$group
grann_lab <- unique(clusters_dt[match(rownames(plot_mt), gene)]$group)
grann <- factor(grann, levels = grann_lab)
module_ann <- HeatmapAnnotation(
    which = "row", border = TRUE,
    "group" = anno_block(
      labels = grann_lab,
      gp = gpar(col = NA)
    )
)
row_split <- grann

# genes annotations
marks_gold <- fread(
  file.path("annotation", "golden-marks-230116.tsv"),
  fill = TRUE
)[, 1:2]
setnames(marks_gold, c("gene", "name"))
marks_gold[, name := str_remove(name, "^Nv")]

tfs_annt <- fread(
  file.path("annotation", "curated_TFh_Nvec_DToL_names.tsv"),
  header = FALSE
)
setnames(tfs_annt, c("gene", "pfam", "og"))

marks_tfs <- merge.data.table(
  tfs_annt,
  marks_gold,
  by = "gene", all = TRUE, sort = FALSE
)
marks_tfs[is.na(marks_tfs)] <- ""
marks_tfs <- marks_tfs[gene %in% rownames(plot_mt)]
marks_tfs[
  gene %in% clusters_dt[group==5]$gene,
  name := str_replace_all(og, c(
    "HMGbox_Sox.HG1.25:like:BHMG1/SOX1/SOX2/SOX3/SOX14/SOX15/SOX21/SRY:likeclu:18/26/28" = "SOX1/2/3/14/15/21-like",
    "zf-C2H2.HG5.17:PRDM6" = "zf-C2H2 PRDM6",
    "zf-C2H2.Unclassified" = ""
  ))
]
marks_tfs <- marks_tfs[name != ""]

row_labels_marks_ids <- match(marks_tfs$gene, rownames(plot_mt))
row_labels_marks <- marks_tfs[
  match(rownames(plot_mt)[row_labels_marks_ids], gene)
]$name
mark_ann <- HeatmapAnnotation(
    which = "row", border = TRUE,
    "padj<0.01" = rownames(plot_mt) %in% genes_deseq,
    # "var>1" = rownames(plot_mt) %in% genes_vari,
    #"FC>2" = rownames(plot_mt) %in% genes_fc,
    "marker" = anno_mark(
      at = row_labels_marks_ids,
      labels = row_labels_marks
    ),
    col = list(
      "padj<0.01" = c("TRUE" = "#e6ab02", "FALSE"="#d9d9d9"),
      "var>1" = c("TRUE" = "#3690c0", "FALSE"="#d9d9d9"),
      "FC>2" = c("TRUE" = "#e7298a", "FALSE"="#d9d9d9")
    )
)

# heatmap
hm <- Heatmap(
  plot_mt, name = "normalized\naccessibility",
  col = col_fun,
  cluster_rows = FALSE, cluster_columns = FALSE,
  show_row_names = FALSE, show_column_names = TRUE,
  row_title = "genes",
  row_split = row_split,
  cluster_row_slices = FALSE,
  top_annotation = col_ann, 
  right_annotation = mark_ann,
  left_annotation = module_ann,
  border = TRUE
)
hm
```

```{r include=FALSE, eval=TRUE}
pdf(
  file.path(fig_dir, "clustering_heatmap_genes.pdf"),
  width = 10, height = 12
)
draw(hm)
dev.off()
```

## Motifs

Score archetype motifs in consensus peaks

```{r eval=FALSE}
require(universalmotif)
require(monalisa)

# motifs
mots_lst <- readRDS(
  file.path("annotation", "motif-archetypes-PPM-PCCnorm-0.8-IC0.5-8bp-pwms.rds")
)
mona_lst <- mta_convert_umot_to_monalisa(mots_lst)

# peaks
peaks <- fread(file.path(cns_dir, "consensusSeekeR-peaks.bed"))
setnames(peaks, c("seqnames", "start", "end", "name", "score", "strand"))
peaks_gr <- makeGRangesFromDataFrame(peaks, keep.extra.columns = TRUE)

# genome
genome <- Biostrings::readDNAStringSet("genome/Nvec_vc1.1_gDNA.fasta")
seqdt <- fread("genome/Nvec_vc1.1_gDNA.fasta.fai")[,1:2]
seqlvl <- c(seqdt[[1]], "ENA|OW052000|OW052000.1")

# scanning
mta_scores_mona <- mta_gw_motif_score_monalisa(
  motifs = mona_lst,
  genome_object = genome,
  index_object = seqdt,
  bin_width = 250,
  subsample_fraction = 0.10,
  score_quantiles = c(0, 0.25, 0.5, 0.75, 0.8, 0.9, 0.95, 0.98, 0.99, 0.995, 0.999, 1.0),
  score_quantile_thr = 0.8,
  do_gw_scan = TRUE,
  given_gr = peaks_gr,
  nthreads = 16
)
saveRDS(
  mta_scores_mona, 
  file.path(res_dir, "motif-scores-archetypes-mona-0.8.rds")
)

# map motifs back to peaks
mta_hits <- mta_scores_mona$gw_scan
mta_cent <- narrow(mta_hits, start = width(mta_hits)/2, width = 1)
mta_ovls <- findOverlaps(query = mta_hits, subject = peaks_gr)
mta_scor <- mta_hits[queryHits(mta_ovls)]
pro_scor <- peaks_gr[subjectHits(mta_ovls)]
mcols(mta_scor) <- cbind(mcols(mta_scor), mcols(pro_scor))

# add genes
assign <- fread(
  file.path(res_dir, "consensusSeekeR-peaks-gene-assignment.tsv")
)[, .(peak, gene)]
mta_data <- as.data.table(mta_scor)
mta_data[, score := NULL]
setnames(mta_data, c("name", "motif_score"), c("peak", "score"))
mta_annt <- merge.data.table(
  mta_data, assign,
  by = "peak",
  all.x = TRUE,
  allow.cartesian = TRUE
)
mta_annt[is.na(gene), gene := ""]
setcolorder(mta_annt, colnames(mta_data))

# order
mta_annt[, peak := factor(peak, levels = peaks$name)]
setkey(mta_annt, peak)
mta_annt <- unique(mta_annt)

# save
fwrite(
  mta_annt,
  file.path(res_dir, "motif-scores-archetypes-mona-0.8-annot.tsv"),
  sep = "\t"
)

```

Motif to TF assignment

```{r}
# assignment
dc <- fread(file.path(
  "annotation",
  "assignment-archetype-motif-gene.tsv.gz"
))[, .(gene, archetype_name)]
dc[, motif := str_extract(archetype_name, "ARCH\\d+")]
dc[, archetype_name := NULL]

# motifs
mots_nms <- sapply(mots_lst, function(i) str_extract(i@name, "ARCH\\d+"))
names(mots_lst) <- mots_nms

# plot motif logos
require(ggseqlogo)
pdf(
  file.path(fig_dir, "motifs-tfs-logo.pdf"),
  width = 8, height = 4
)
for (i in seq_len(nrow(dc))) {
  mn <- dc[i, motif]
  gn <- dc[i, gene]
  pf <- gene_ann[gene == gn, pfam]
  nm <- gene_ann[gene == gn, name]
  mt <- mots_lst[[mn]]@motif
  gg_mot <- ggseqlogo(mt) + labs(title = sprintf(
    "%s\n%s\n%s\n%s", mn, gn, nm, pf
  ))
  print(gg_mot)
}
dev.off()

# save pwms for TFs
mots_tfs <- mots_lst[unique(dc$motif)]
write_meme(
  mots_tfs,
  file.path("annotation/motif-archetypes-PPM-PCCnorm-0.8-IC0.5-8bp-pwms-tfs.meme"),
  overwrite = TRUE
)
```

Motif enrichment in groups defined before

```{r eval=FALSE}
# load peaks clustering to groups
pks <- fread(
  file.path(res_dir, "consensusSeekeR-peaks-clusters.bed")
)
setnames(pks, c("V4", "V8"), c("peak", "group"))
pks[, peak := factor(peak, levels = unique(pks$peak))]
pks[, group := factor(
  group,
  levels = paste0("G", sort(as.integer(str_remove(unique(pks$group), "G"))))
)]
setkey(pks, group, peak)

mta_scores_mona <- readRDS(
  file.path(res_dir, "motif-scores-archetypes-mona.rds")
)

sites_gr <- mta_scores_mona$gw_scan
sites_gr$name <- sites_gr$motif

enr_list <- lapply(as.character(levels(pks$group)), function(g) {

  enr_df <- mta_motif_enrichment_test(
    sites_object = sites_gr,
    peaks_object = peaks_gr,
    fg_list = peaks_gr[peaks_gr$name %in% pks[group == g]$peak]$name,
    bg_list = peaks_gr[!peaks_gr$name %in% pks[group == g]$peak]$name,
    thresholds_vector = NULL, # mta_scores_mona$score_quantiles[,"0.95"],
    label = g,
    nthreads = 2,
    pval_adjust = "BH"
  )
  setDT(enr_df)
  enr_df

})
enr_dt <- rbindlist(enr_list)

# save
fwrite(
  enr_dt,
  file.path(res_dir, "motif-enrich-archetypes-mona.tsv"),
  sep = "\t"
)
```

Cluster significant motifs

```{r}
# enrichment scores
dt <- fread(
  file.path(res_dir, "motif-enrich-archetypes-mona.tsv")
)
setnames(dt, c("label", "motif"), c("group", "archetype_name"))
dt[, motif := str_extract(archetype_name, "ARCH\\d+")]

# add motif to tf assignment
dt <- merge.data.table(
  dt, dc, by = "motif",
  all.x = TRUE, sort = FALSE, allow.cartesian = TRUE
)

# qvalue
dat_qv <- dcast.data.table(
  unique(dt[, .(motif, group, padj)]), motif ~ group, value.var = "padj"
)
mat_qv <- data.matrix(dat_qv)[, -1]
mat_qv[is.na(mat_qv)] <- 1
rownames(mat_qv) <- dat_qv$motif
write.table(
  mat_qv,
  file.path(
    res_dir, "motif-enrich-archetypes-mona-qvalue.tsv"
  ),
  sep = "\t", quote = FALSE
)

# log2fc
dat_fc <- dcast.data.table(
  unique(dt[, .(motif, group, fc)]), motif ~ group, value.var = "fc"
)
mat_fc <- data.matrix(dat_fc)[, -1]
mat_fc[is.na(mat_fc)] <- 0
rownames(mat_fc) <- dat_fc$motif
write.table(
  mat_fc,
  file.path(res_dir, "motif-enrich-archetypes-mona-fc.tsv"),
  sep = "\t", quote = FALSE
)

# highly significant higher value
dt[, minuslog10qval := -1 * log10(padj)]

# filtering
ids <- apply(mat_fc, 1, function(x) max(x) > 1) &
  apply(mat_qv, 1, function(x) !is.infinite(min(x)) & !min(x) > 0.05)

# clustering
hc <- hclust(dist(mat_fc[ids, ]), method = "ward.D2")
ds <- dt[motif %in% rownames(mat_fc)[ids]]
ds[, motif := factor(motif, levels = rev(rownames(mat_fc)[ids]))]

# ordering
mord <- order(apply(mat_fc[ids,], 1, which.max))
ds[, motif := factor(motif, levels = rev(rownames(mat_fc[ids, ])[mord]))]

# limit -log10FDR range
ds[, minuslog10qval := pmin(minuslog10qval, 20)]

# golden marks annotations
marks_gold <- fread(
  file.path("annotation", "golden-marks-231124.tsv"),
  sep = "\t", header = FALSE, fill = TRUE
)[, c(2, 1)]
setnames(marks_gold, c("gene", "name"))

# tf annotations
tfs_annt <- fread(
  file.path("annotation", "tfs.Nvec.tsv"),
  header = TRUE
)[, .SD[1], gene]

# add annotations
marks_tfs <- merge.data.table(
  tfs_annt,
  marks_gold,
  by = "gene", all = TRUE, sort = FALSE
)
marks_tfs[is.na(marks_tfs)] <- ""
mt_marks_ <- merge.data.table(
  ds, marks_tfs,
  by = "gene",
  all.x = TRUE
)
mt_marks_[, motif := factor(motif, levels = levels(ds$motif))]
setorder(mt_marks_, motif)
mt_marks_[is.na(name), name := ""]

# add labels
mt_marks_dt <- copy(mt_marks_)
mt_marks_dt[name == "" & pfam != "", name := pfam]
mt_marks_dt[name == "" & og != "", name := og]
mt_marks_dt[, label := name]
mt_marks_dt[label == "", label := archetype_name]
mt_marks_dt[!grepl("^ARCH", label), label := paste(motif, label)]
mt_marks_dt[, label := substr(label, 1, 35)]
mt_marks_dt[, label := factor(label, levels = unique(mt_marks_dt$label))]
```

All significant motifs enrichment heatmap

```{r fig.height=20, fig.width=8}
# plot
gp <- ggplot(mt_marks_dt, aes(group, label, label = label)) +
  geom_point(
    aes(size = minuslog10qval, fill = fc),
    shape = 21,
    color = "black"
  ) +
  scale_fill_gradientn(
    name = "enrichmnet\nfold change",
    # breaks = c(0, 1, 2, 4, 6),
    colours = c(
      "white", "#fee5d9", "#fcae91", "#fb6a4a", "#de2d26", "#a50f15", "#7a0105"
    )
  ) +
  scale_size_continuous(
    name = "-log10 FDR",
    breaks = c(0, 10, 20)
  ) +
  theme(
    panel.grid.major = element_line(size = 0.25),
    axis.text.y = element_text(size = 8),
    axis.text.x = element_text(size = 8, angle = 90, vjust = 0.5, hjust = 1),
    legend.direction = "vertical"
  )
```

```{r include=FALSE, eval=TRUE}
pdf(
  file.path(fig_dir, "motifs-heatmap.pdf"),
  width = 6, height = 20
)
gp
dev.off()
```

```{r fig.height=5, fig.width=6.5}
# clustering
hc <- hclust(dist(mat_fc), method = "ward.D2")
ds <- dt[motif %in% rownames(mat_fc)]
ds[, motif := factor(motif, levels = rev(rownames(mat_fc)))]

# limit -log10FDR range
ds[, minuslog10qval := pmin(minuslog10qval, 6)]

# golden marks annotations
marks_gold <- fread(
  file.path("annotation", "golden-marks-231124.tsv"),
  sep = "\t", header = FALSE, fill = TRUE
)[, c(2, 1)]
setnames(marks_gold, c("gene", "name"))

# tf annotations
tfs_annt <- fread(
  file.path("annotation", "tfs.Nvec.tsv"),
  header = TRUE
)[, .SD[1], gene]

# add annotations
marks_tfs <- merge.data.table(
  tfs_annt,
  marks_gold,
  by = "gene", all = TRUE, sort = FALSE
)
marks_tfs[is.na(marks_tfs)] <- ""
mt_marks_ <- merge.data.table(
  ds, marks_tfs,
  by = "gene",
  all.x = TRUE
)

# selected TFs
seleceted_tfs <- c(
  "GATA"  ="Nvec_vc1.1_XM_032367288.2",
  "Islet" = "Nvec_vc1.1_XM_032362713.2",
  #"OtxC" = "Nvec_vc1.1_XM_001647471.3",
  "RFX4/6/8" = "Nvec_vc1.1_XM_032365096.2",
  "Jun" = "Nvec_vc1.1_XM_032385896.2",
  #"Fos1" = "Nvec_vc1.1_XM_048730161.1",
  "FoxQ2d" = "Nvec_vc1.1_XM_032385706.2",
  "Pou4" = "Nvec_vc1.1_XM_032363992.2",
  "FoxL2" = "Nvec_vc1.1_XM_032364887.2",
  "AshA" = "Nvec_vc1.1_XM_032370984.2",
  "ZNF845" = "Nvec_vc1.1_XM_001641129.3"
)
mt_marks_selected_tfs <- mt_marks_[gene %in% seleceted_tfs]
mt_marks_selected_tfs[, gene := factor(gene, levels = rev(seleceted_tfs))]
setorder(mt_marks_selected_tfs, gene)
mt_marks_selected_tfs[, name := factor(name, levels = unique(mt_marks_selected_tfs$name))]

gp <- ggplot(mt_marks_selected_tfs, aes(group, name, size = minuslog10qval, fill = fc)) +
  geom_point(shape = 21) +  
  scale_fill_gradientn(
    name = "enrichmnet\nfold change",
    colours = c(
      "white", "#fee5d9", "#fcae91", "#fb6a4a", "#de2d26", "#a50f15", "#7a0105"
    ),
    breaks = seq(0, 6, 2)
  ) +
  scale_size_continuous(
    name = "-log10 FDR",
    range = c(1, 10),
    breaks = seq(0, 6, 2)
  )
gp
```

```{r include=FALSE, eval=TRUE}
pdf(
  file.path(fig_dir, "motifs-tfs-selected-heatmap.pdf"),
  width = 6, height = 5
)
gp
dev.off()
```

Significant motifs assigned to TFs enrichment heatmap

```{r fig.height=8, fig.width=8}
mt_marks_tf <- mt_marks_[!is.na(gene)]

# one entry per motif
mt_marks_tf <- mt_marks_tf[, .SD[1], .(motif, group)]
mt_marks_tf <- mt_marks_tf[order(-name)][,.SD[1], .(motif, group)]

# label
mt_marks_tf[name == "" & pfam != "", name := pfam]
mt_marks_tf[name == "" & og != "", name := og]
mt_marks_tf[, name := substr(name, 1, 45)]
mt_marks_tf[, label := paste(
  name, gene, motif, sep = " | "
)]
mt_marks_tf[, label := factor(label, levels = unique(mt_marks_tf$label))]
mt_marks_tf[, name := factor(name, levels = unique(mt_marks_tf$name))]

# plot
gp <- ggplot(mt_marks_tf, aes(group, name, label = label)) +
  geom_point(
    aes(size = minuslog10qval, fill = fc),
    shape = 21,
    color = "black"
  ) +
  scale_fill_gradientn(
    name = "enrichmnet\nfold change",
    # breaks = c(0, 1, 2, 4, 6),
    colours = c(
      "white", "#fee5d9", "#fcae91", "#fb6a4a", "#de2d26", "#a50f15", "#7a0105"
    )
  ) +
  scale_size_continuous(
    name = "-log10 FDR",
    breaks = c(0, 10, 20)
  ) +
  theme(
    panel.grid.major = element_line(size = 0.25),
    axis.text.y = element_text(size = 8),
    axis.text.x = element_text(size = 8, angle = 90, vjust = 0.5, hjust = 1),
    legend.direction = "vertical"
  )
gp
```

```{r include=FALSE, eval=TRUE}
pdf(
  file.path(fig_dir, "motifs-tfs-heatmap.pdf"),
  width = 10, height = 12
)
gp
dev.off()
```

How many expressed TFs have motifs?

```{r}
# TF annotation
tfs_annt <- fread(
  file.path("annotation", "tfs.Nvec.tsv"),
  header = TRUE
)[, .SD[1], gene]

# groupped genes
mark_dt <- fread(file.path(
  "RNASEQ_QUANTIFICATION", "results", "genes_clusters.tsv"
))
mark_dt[, group := paste0("G", group)]
gene_dt <- fread(file.path(
  "RNASEQ_QUANTIFICATION", "results", "genes_clusters_predicted.tsv"
))
gene_dt[, group := group_xgb]
group_dt <- rbindlist(list(
  clustered = mark_dt[, .(gene, group)],
  predicted = gene_dt[, .(gene, group)]
),  idcol = "method")
group_dt[, group := factor(
  group,
  levels = paste0("G", unique(
    sort(as.integer(str_remove(group_dt$group, "G")))
  ))
)]
message(sprintf(
  "Total genes: %i", length(group_dt$gene)
))

# expressed genes
con_mt <- read.table(
  file.path("RNASEQ_QUANTIFICATION", "raw_counts_rnaseq.tsv"),
  header=TRUE, row.names = 1
)
expr_genes <- names(which(apply(con_mt, 1, function(x) sum(x) > 100) == TRUE))
message(sprintf(
  "Expressed genes: %i", length(expr_genes)
))

# expressed TFs
expr_tfs <- expr_genes[expr_genes %in% tfs_annt$gene]
message(sprintf(
  "Expressed TFs: %i", length(expr_tfs)
))

# motif to tf assignment
dc <- fread(file.path(
  "annotation",
  "assignment-archetype-motif-gene.tsv.gz"
))[, .(gene, archetype_name)]

# expressed TFs with motif
expr_dt <- group_dt[gene %in% expr_genes]
expr_dt[, TF := gene %in% expr_tfs]
expr_dt[, TF := factor(TF, levels = c(TRUE, FALSE))]
setorder(expr_dt, group, TF)
expr_dt <- merge.data.table(
  expr_dt, dc, by = "gene", all.x = TRUE, sort = FALSE
)
expr_tfs_mot <- unique(expr_dt[TF==TRUE & !is.na(archetype_name)]$gene)
message(sprintf(
  "Expressed TFs with motif assigned: %i/%i (%.2f%%)",
  length(expr_tfs_mot), length(expr_tfs),
  length(expr_tfs_mot) / length(expr_tfs) * 100
))
```

## Footprinting

```{bash include=FALSE, eval=FALSE}
# install TOBIAS
cd /home/anamaria/bin/
git clone https://github.com/loosolab/TOBIAS.git
cd TOBIAS
cp tobias_env.yaml tobias.yaml
# set env name to tobias
# include python version (python==3.8)
# remove svist4get because it causes conflict that cannot be solved
mamba env create -f tobias.yaml
mamba activate tobias
pip install xgboost
pip install svist4get
pip install tobias
```

Merge replicates per condition

```{bash eval=FALSE}
bam_dir="ATACSEQ/nucleosome_free_regions/bam/"
nth=18

for line in Fox Elav Ncol
do
  for cond in pos neg
  do
    name=${line}_${cond}
    echo ${name}
    bams=$( echo ${bam_dir}/${name}*bam )
    samtools merge -@ ${nth} ${bam_dir}/${name}.ncfree.bam ${bams}
    samtools sort -@ ${nth} -o ${bam_dir}/${name}.ncfree.sorted.bam ${bam_dir}/${name}.ncfree.bam
    rm ${bam_dir}/${name}.ncfree.bam
    samtools index -@ ${nth} ${bam_dir}/${name}.ncfree.sorted.bam
  done
done
```

Footprint score calculation for consensus peaks

```{bash eval=FALSE}
conda activate TOBIAS_ENV
bam_dir="ATACSEQ/nucleosome_free_regions/bam/"
out_dir="ATACSEQ/nucleosome_free_regions/footprint/"
mkdir ${out_dir}
peaks="ATACSEQ/nucleosome_free_regions/consensus_peaks/consensusSeekeR-peaks.bed"
genome="genome/Nvec_vc1.1_gDNA.fasta"
nth=12

for line in Fox Elav Ncol
do
  for cond in pos neg
  do
    name=${line}_${cond}
    
    echo $(date) "- Starting ATACorrect for" ${name}
    TOBIAS ATACorrect \
      --bam ${bam_dir}/${name}.ncfree.sorted.bam \
      --genome ${genome} \
      --peaks ${peaks} \
      --prefix ${name} \
      --outdir ${out_dir}/ATACorrect \
      --cores ${nth}
    
    echo $(date) "- Starting FootprintScores"
    TOBIAS FootprintScores \
      --signal ${out_dir}/ATACorrect/${name}_corrected.bw \
      --regions ${peaks} \
      --fp-min 10 --fp-max 50 \
      --output ${out_dir}/${name}_footprints.bw \
      --cores ${nth}
    
  done
done

```

Plot difference in footprints

```{bash eval=FALSE}
conda activate TOBIAS_ENV
bam_dir="ATACSEQ/nucleosome_free_regions/bam/"
bwg_dir="ATACSEQ/nucleosome_free_regions/footprint/ATACorrect"
plt_dir="ATACSEQ/nucleosome_free_regions/footprint/plots"
mkdir ${plt_dir}
peaks="ATACSEQ/nucleosome_free_regions/consensus_peaks/consensusSeekeR-peaks.bed"

for line in Fox Elav Ncol
do
  TOBIAS PlotAggregate --TFBS ${peaks} \
    --signals ${bwg_dir}/${line}_pos_corrected.bw ${bwg_dir}/${line}_neg_corrected.bw \
    --output ${plt_dir}/${line}_footprint_comparison_all_peaks.pdf \
    --flank 125 \
    --share_y both \
    --plot_boundaries \
    --signal-on-x
done

TOBIAS PlotAggregate --TFBS ${peaks} \
  --signals ${bwg_dir}/Elav_pos_corrected.bw ${bwg_dir}/Fox_pos_corrected.bw ${bwg_dir}/Ncol_pos_corrected.bw \
  --output ${plt_dir}/pos_footprint_comparison_all_peaks.pdf \
  --flank 150 \
  --share_y both \
  --plot_boundaries \
  --signal-on-x

```

## TOBIAS motif scores

Combine motif scores and footprint scores to determine motif binding.

```{bash eval=FALSE}
mamba activate tobias
bwg_dir="ATACSEQ/nucleosome_free_regions/footprint/"
out_dir="ATACSEQ/nucleosome_free_regions/footprint/BINDetect"
mkdir ${out_dir}
peaks="ATACSEQ/nucleosome_free_regions/consensus_peaks/consensusSeekeR-peaks.bed"
motifs="annotation/motif-archetypes-PPM-PCCnorm-0.8-IC0.5-8bp-pwms-tfs.meme"
genome="genome/Nvec_vc1.1_gDNA.fasta"
nth=12

# have to split motifs in multiple files because of the open file limit
#for x in {1..4}
#do
#  motifs="annotation/motif-archetypes-PPM-PCCnorm-0.8-IC0.5-8bp-pwms-binned/motif-archetypes-PPM-PCCnorm-0.8-IC0.5-8bp-pwms-bin"${x}".meme"

# alternatively, motifs for TFs only
  x="tfs"

  line1=Fox
  line2=Elav
  line3=Ncol

  mkdir ${out_dir}/${x}
  echo $(date) "- Starting BINDetect for" ${x} 

  TOBIAS BINDetect \
    --motifs ${motifs} \
    --signals \
      ${bwg_dir}/${line1}_pos_footprints.bw \
      ${bwg_dir}/${line1}_neg_footprints.bw \
      ${bwg_dir}/${line2}_pos_footprints.bw \
      ${bwg_dir}/${line2}_neg_footprints.bw \
      ${bwg_dir}/${line3}_pos_footprints.bw \
      ${bwg_dir}/${line3}_neg_footprints.bw \
    --genome ${genome} \
    --peaks ${peaks} \
    --outdir ${out_dir}/${x} \
    --cond_names \
      ${line1}_pos ${line1}_neg \
      ${line2}_pos ${line2}_neg \
      ${line3}_pos ${line3}_neg \
    --cores ${nth}

#done
```

Plot footprints for selected TFs

```{r}
dt=unique(fread("annotation/assignment-archetype-motif-gene.tsv.gz")[,.(archetype_name,gene)])
gold=fread("annotation/golden-marks-231124.tsv",header=FALSE)
setnames(gold,c("name","gene","cts"))
unique(merge.data.table(dt,gold,by="gene")[,.(archetype_name,gene,name)])
gold_dt=unique(merge.data.table(dt,gold,by="gene")[,.(archetype_name,gene,name,cts)])[order(cts)][,archetype_name:=str_extract(archetype_name,"ARCH\\d+")]
```

```{bash}
mamba activate tobias
bwg_dir="ATACSEQ/nucleosome_free_regions/footprint/"
out_dir="ATACSEQ/nucleosome_free_regions/footprint/BINDetect"
mkdir ${out_dir}
peaks="ATACSEQ/nucleosome_free_regions/consensus_peaks/consensusSeekeR-peaks.bed"
motifs="annotation/motif-archetypes-PPM-PCCnorm-0.8-IC0.5-8bp-pwms.meme"
genome="genome/Nvec_vc1.1_gDNA.fasta"
nth=12
x="tfs"

# GATA
mot="_ARCH738_GATA_Nvec_vc1.1_XM_032"
line="Elav"

# Islet
mot="_ARCH906_Homeodomains_Nvec_vc1."
line="Elav"
line="Ncol"

# Rfx4/6/8
mot="_ARCH1358_RFX_Nvec_vc1.1_XM_032"
line="Fox"

# Jun/Fos
mot="_ARCH146_bZIP_Nvec_vc1.1_XM_001"
line="Fox"

# FoxQ2d
mot="_ARCH673_Forkhead_Nvec_vc1.1_XM"
line="Ncol"

# Pou4
mot="_ARCH1151_Pit11bp_POU4F1_Pit"
line="Ncol"

# FoxL2
mot="_ARCH671_Forkhead_Nvec_vc1.1_XM"
line="Ncol"

# AshA
mot="_ARCH560_PL0011.1_hlh-2__hlh-4"
line="Ncol"

# ZNF845
mot="_ARCH292_zf_C2H2_Nvec_vc1.1_XM_"
line="Ncol"

# PaxA
mot="_ARCH636_Homeodomains_Nvec_vc1."

# SoxC
mot="_ARCH1434_HMGbox_Sox_Nvec_vc1.1"

# Nvec_vc1.1_XM_032363168.2 ZMAT1/ZMAT3/ZMAT4/ZNF346/ZNF385A/ZNF385B/ZNF385C/ZNF385D
# Nvec_vc1.1_XM_032363951.2 NFYB_NFYC.HG1.5:NFYB
mot="_ARCH202_OCT_OCT_OCT_OCT_OCT_"

# Nvec_NVE7697 like:LEUTX
# Nvec_vc1.1_XM_032377390.2 VAX1/VAX2 (expressed in ElavPos)...
mot="_ARCH956_Homeodomains_Nvec_vc1."

# pos vs neg for chooesn line
TOBIAS PlotAggregate \
  --TFBS ${out_dir}/${x}/${mot}/beds/${mot}_${line}_pos_bound.bed ${out_dir}/${x}/${mot}/beds/${mot}_${line}_pos_unbound.bed \
  --signals ${bwg_dir}/ATACorrect/${line}_pos_corrected.bw ${bwg_dir}/ATACorrect/${line}_neg_corrected.bw \
  --output ${out_dir}/${x}/${mot}/plots/${mot}_${line}_footprint.png --share_y sites --plot_boundaries

# pos line1 vs line2 vs line3
line1="Elav"
line2="Fox"
line3="Ncol"
TOBIAS PlotAggregate \
  --TFBS \
  ${out_dir}/${x}/${mot}/beds/${mot}_${line1}_pos_bound.bed \
  ${out_dir}/${x}/${mot}/beds/${mot}_${line2}_pos_bound.bed \
  ${out_dir}/${x}/${mot}/beds/${mot}_${line3}_pos_bound.bed \
  ${out_dir}/${x}/${mot}/beds/${mot}_${line1}_pos_unbound.bed \
  ${out_dir}/${x}/${mot}/beds/${mot}_${line2}_pos_unbound.bed \
  ${out_dir}/${x}/${mot}/beds/${mot}_${line3}_pos_unbound.bed \
  --signals \
  ${bwg_dir}/ATACorrect/${line1}_pos_corrected.bw \
  ${bwg_dir}/ATACorrect/${line2}_pos_corrected.bw \
  ${bwg_dir}/ATACorrect/${line3}_pos_corrected.bw \
  --output ${out_dir}/${x}/${mot}/plots/${mot}_${line1}_${line2}_${line3}_footprint.pdf \
  --output-txt ${out_dir}/${x}/${mot}/plots/${mot}_${line1}_${line2}_${line3}_footprint.txt \
  --share_y sites --plot_boundaries

# loop
mots=$(for file in ATACSEQ/nucleosome_free_regions/footprint/BINDetect/tfs/_*/_*png; do basename "$file" .png; done)
for mot in $mots
do
  for line in Elav Ncol Fox
  do
      echo ${mot} ${line}
      TOBIAS PlotAggregate \
        --TFBS \
        ${out_dir}/${x}/${mot}/beds/${mot}_${line}_pos_bound.bed \
        ${out_dir}/${x}/${mot}/beds/${mot}_${line}_pos_unbound.bed \
        --signals \
        ${bwg_dir}/ATACorrect/${line}_pos_corrected.bw \
        ${bwg_dir}/ATACorrect/${line}_neg_corrected.bw \
        --output \
        ${out_dir}/${x}/${mot}/plots/${mot}_${line}_footprint.png \
        --share_y sites --plot_boundaries
  done
done
```

```{r fig.height=12, fig.width=12}
# function to parse footprints txt files saved by TOBIAS PlotAggregate
parse_footprints <- function(ftp_fn) {
  ftp_dt <- fread(ftp_fn, skip = 1)
  setnames(ftp_dt, c("sample", "region", "signals"))
  # split values in signals by "," into individual columns
  ftp_dt[, paste0("p", seq_len(120)) := tstrsplit(signals, ",", fixed = TRUE)]
  ftp_dt[, signals := NULL]
  # melt to long format for plotting
  ftp_dt <- melt(ftp_dt, id.vars = c("sample", "region"), variable.name = "position", value.name = "signal")
  ftp_dt[, position := as.integer(str_remove(position, "p"))]
  ftp_dt[, signal := as.numeric(signal)]
  # fix names
  ftp_dt[, sample := str_remove(sample, "_corrected")]
  ftp_dt[, region := str_extract(region, "(Elav|Ncol|Fox)_(pos|neg)_(un)*bound")]
  # return
  return(ftp_dt)
}

# motif to tf assignment
dc <- fread(file.path(
  "annotation",
  "assignment-archetype-motif-gene.tsv.gz"
))[, .(gene, archetype_name)]

# golden marker tfs
marks_neuro <- marks_gold[grepl("neuro|cnido",cts)]
marks_gold_tfs <- marks_neuro[,setNames(gene, name)]

# loop for all marker tfs
ftp_ls <-lapply(seq_along(marks_gold_tfs), function(i) {
  
  # gene ID and name
  tf_name <- unname(marks_gold_tfs[i])
  tf <- names(marks_gold_tfs[i])
  print(sprintf("%s/%s: %s (%s)",i, length(marks_gold_tfs) , tf_name, tf))
  
  # find motif
  arch <- str_extract(dc[gene==tf]$archetype_name[1], "ARCH\\d+_")
  if (!is.na(arch)) {
    mot_dir <- grep(arch, list.dirs(file.path(ftp_dir,"BINDetect","tfs"), recursive=FALSE), value=TRUE)
    mot <- basename(mot_dir)
    
    # load footprint data, create if doesn't exist
    ftp_fn <- file.path(mot_dir,"plots",sprintf("%s_%s_%s_%s_footprint.txt",mot,line1,line2,line3))
    if (!file.exists(ftp_fn)) {
      tobias_plot_cmd <- sprintf(
        "TOBIAS PlotAggregate --TFBS %s/beds/*bed --signals %s/footprint/ATACorrect/*_pos_corrected.bw --output %s/plots/%s_Elav_Fox_Ncol_footprint.pdf --output-txt  %s/plots/%s_Elav_Fox_Ncol_footprint.txt --share_y sites --plot_boundaries",
        mot_dir, dat_dir, mot_dir, basename(mot_dir), mot_dir, basename(mot_dir)
      )
      #system(tobias_plot_cmd)
      print(tobias_plot_cmd)
      print("")
    } else {
      ftp_dt <- parse_footprints(ftp_fn)
      ftp_dt[, gene := tf][, gene_name := tf_name]
      ftp_dt
    }
  }
})
ftp_dt <- rbindlist(ftp_ls[ftp_ls!=""])

# plot
ftp_dt[, bound := str_extract(region, "(un)*bound")]
ftp_dt[, ovl := grepl(sample,region), by=1:nrow(ftp_dt)]
ftp_dt[, centered_position := position - max(position) / 2]
ftp_gp <- ggplot(ftp_dt[ovl==TRUE], aes(centered_position, signal, color = sample, linetype = bound)) +
  geom_line(size = 0.25) +
  theme(legend.position = "bottom") +
  scale_color_manual(values = line_cond_cols) +
  facet_wrap("gene_name", scales = "free") +
  labs(x = "distance from motif center") +
  theme(
    panel.grid.major = element_line(color = "gray", linewidth = 0.1),
    text = element_text(size = 18), strip.text = element_text(size = 18)
  )
ftp_gp
```

```{r include=FALSE, eval=TRUE}
pdf(
  file.path(fig_dir, "Footprint_neuron_markers.pdf"),
  width = 11, height = 10
)
ftp_gp
dev.off()
```

Combine motif binding scores

```{r eval=FALSE}
bind_dir <- file.path(dat_dir, "footprint", "BINDetect")
bind_dt <- rbindlist(lapply(c("tfs"), function(x) {
  fn <- list.files(
    file.path(bind_dir, x),
    pattern = "bindetect_results.txt", full.names = TRUE
  )
  dt <- fread(fn)
  dt[, name := NULL]
  dt[, output_prefix := NULL]
  dt[, cluster := NULL]
  dt
}))
fwrite(bind_dt, file.path(
  bind_dir, "bindetect_results.txt"
), sep = "\t")
```

Volcano plots

```{r fig.height=6, fig.width=10}
# bindetect results
bind_dt <- fread(file.path(
  bind_dir, "bindetect_results.txt"
))

# save rds
saveRDS(bind_dt, file.path(
  res_dir, "bindetect_results.rds"
))

# coparisons
comparas <- list(
  c("Fox_pos", "Fox_neg"),
  c("Elav_pos", "Elav_neg"),
  c("Ncol_pos", "Ncol_neg"),
  c("Fox_pos", "Elav_pos"),
  c("Fox_pos", "Ncol_pos"),
  c("Elav_pos", "Ncol_pos")
)

# volcano plots
gpv_list <- lapply(comparas, function(x) {
  cols <- c(
    "motif_id",
    sprintf("%s_%s_change", x[[1]], x[[2]]),
    sprintf("%s_%s_pvalue", x[[1]], x[[2]])
  )
  dt <- unique(bind_dt[, ..cols])
  setnames(dt, c("motif_name", "log2FoldChange", "pvalue"))
  dt[, motif := str_extract(motif_name, "ARCH\\d+")]
  dt <- merge.data.table(dt, dc_tf, by = "motif", all.x = TRUE)
  dt[, motif_label := name]
  dt[motif_label == "", name := pfam]
  dt[, motif_label := str_remove(motif_label, ".+(?<=:)")]
  dt[, motif_label := strtrim(motif_label, 10)]
  dt[, minuslog10pval := -1 * log10(pvalue)]
  dt[, minuslog10padj := NA]
  dt <- unique(dt[, .(motif, log2FoldChange, pvalue, minuslog10pval, minuslog10padj, motif_label)])
  ggplotVolcano(
    dt,
    padj_thr = NULL, pval_thr = 0.05,
    lfc_thr = 0.2,
    sign_col = c("red", "blue"),
    lims_fc = c(-0.5, 0.5),
    lims_sig = c(0, 150),
    title = sprintf("%s vs %s", x[[1]], x[[2]]),
    xlab = "differential binding score",
    y = "-log10(p value)",
    label_column = "motif_label", label_size = 3, label_segment_alpha = 0.2,
    label_fc_thr = 0.2,
    label_max_overlaps = 20
  ) +
    theme(panel.grid.major = element_line(color = "gray", linewidth = 0.2))
})

gpv <- (wrap_plots(gpv_list, nrow = 2) & theme(legend.position = "bottom")) +
  plot_layout(guides = "collect")
gpv
```

```{r include=FALSE, eval=TRUE}
pdf(
  file.path(fig_dir, "BINDetect_volcano.pdf"),
  width = 18, height = 10
)
gpv
dev.off()
```

Save parsed results

```{r eval=FALSE}
# parse data
bind_dt <- rbindlist(lapply(comparas, function(x) {
  cols <- c(
    "motif_id",
    sprintf("%s_%s_change", x[[1]], x[[2]]),
    sprintf("%s_%s_pvalue", x[[1]], x[[2]])
  )
  dt <- unique(bind_dt[, ..cols])
  setnames(dt, c("motif_name", "log2FoldChange", "pvalue"))
  dt[, motif := str_extract(motif_name, "ARCH\\d+")]
  dt <- merge.data.table(dt, dc_tf, by = "motif", all.x = TRUE)
  dt[, compara := sprintf("%s_%s", x[[1]], x[[2]])]
  dt
}))
fwrite(bind_dt, file.path(
  bind_dir, "bindetect_results_parsed.txt"
), sep = "\t")
fwrite(bind_dt[pvalue < 0.05], file.path(
  bind_dir, "bindetect_results_significant.txt"
), sep = "\t")
```

Parse all binding scores per sample (from all comparisons)

```{r eval=FALSE}
# load diff motif binding results
hm_dt <- fread(file.path(bind_dir, "bindetect_results_parsed.txt"))
#hm_dt <- fread(file.path(bind_dir, "bindetect_results_significant.txt"))

# get motifs from all comparisons per line
diff_mots_dt <- rbindlist(sapply(c("Elav", "Fox", "Ncol"), function(smp) {
  # select motifs from comparison with neg control
  dt_crt <- hm_dt[compara == sprintf("%s_pos_%s_neg", smp, smp)]
  # select motifs from comparison with other lines
  if (smp == "Elav") {
    dt_dif <- rbindlist(list(
      "neg" = dt_crt,
      "Fox" = hm_dt[compara == "Fox_pos_Elav_pos"][
        , log2FoldChange := -1 * log2FoldChange],
      "Ncol" = hm_dt[compara == "Elav_pos_Ncol_pos"]
    ), idcol = "vs")
  } else if (smp == "Fox") {
    dt_dif <- rbindlist(list(
      "neg" = dt_crt,
      "Elav" = hm_dt[compara == "Fox_pos_Elav_pos"],
      "Ncol" = hm_dt[compara == "Fox_pos_Ncol_pos"]
    ), idcol = "vs")
  } else if (smp == "Ncol") {
    dt_dif <- rbindlist(list(
      "neg" = dt_crt,
      "Fox" = hm_dt[compara == "Fox_pos_Ncol_pos"][
        , log2FoldChange := -1 * log2FoldChange],
      "Elav" = hm_dt[compara == "Elav_pos_Ncol_pos"][
        , log2FoldChange := -1 * log2FoldChange]
    ), idcol = "vs")
  }
  dt_dif[, compara := NULL]
  setcolorder(dt_dif, c("vs", "motif", "log2FoldChange", "pvalue"))
  dt_dif
}, USE.NAMES = TRUE, simplify = FALSE), idcol = "reporterline")

fwrite(
  diff_mots_dt,
  file.path(bind_dir, "bindetect_results_reporterline.txt"),
  sep = "\t"
)
#fwrite(
#  diff_mots_dt,
#  file.path(bind_dir, "bindetect_results_significant_reporterline.txt"),
#  sep = "\t"
#)
```

Plot dotplot

```{r}
# BINDetect results
diff_mots_dt <- fread(file.path(
  bind_dir, "bindetect_results_reporterline.txt"
))

# significant
pval_thr <- 0.05
fc_thr <- 0.2
siginifcant_mots <- diff_mots_dt[
  pvalue < pval_thr & abs(log2FoldChange) > fc_thr
]$motif
dp_dt <- diff_mots_dt[motif %in% siginifcant_mots]
dp_dt[, id := paste(reporterline, vs, sep = " vs ")]

# order samples
dp_dt[, reporterline := factor(reporterline, levels = c("Elav", "Fox", "Ncol"))]
dp_dt[, vs := factor(vs, levels = c("neg", "Elav", "Fox", "Ncol"))]
lv_dt <- CJ(
  levels(dp_dt$reporterline),
  levels(dp_dt$vs)
)[V1 != V2][, id := paste(V1, V2, sep = " vs ")]
lv_dt[, V1 := factor(V1, levels = c("Elav", "Fox", "Ncol"))]
lv_dt[, V2 := factor(V2, levels = c("neg", "Elav", "Fox", "Ncol"))]
setorder(lv_dt, V1, V2)
dp_dt[, id := factor(id, levels = lv_dt$id)]
dp_dt[, motif_id := paste(motif, gene, sep = "__")]

# order motifs
gpv_dt <- dcast.data.table(
  dp_dt, motif_id ~ id, value.var = "log2FoldChange"
)
gpv_mt <- as.matrix(gpv_dt[, -1])
rownames(gpv_mt) <- unique(dp_dt$motif_id)
mord <- rev(order(apply(gpv_mt, 1, which.max)))
mord <- hclust(dist(gpv_mt), method = "ward.D2")$order
dp_dt[, motif_id := factor(motif_id, levels = rownames(gpv_mt)[mord])]
setorder(dp_dt, id, motif_id)

# labels
dp_dt[, motif_label := paste(substr(name, 1, 35), gene, motif, sep = " | ")]
dp_dt[, motif_label := factor(motif_label, levels = unique(dp_dt$motif_label))]

# plot
dp_dt[, minuslog10pvalue := -1 * log10(pvalue)]
gp_dot <- ggplot(dp_dt, aes(
  id, motif_label,
  size = minuslog10pvalue, fill = log2FoldChange
)) +
  geom_point(shape = 21) +
  scale_fill_gradientn(
    colours = colorRampPalette(RColorBrewer::brewer.pal(11, "BrBG"))(1000),
    limits = c(-0.35, 0.35), oob = scales::squish, breaks = c(-0.3, 0, 0.3),
    name = "log2(fold change)",
  ) +
  scale_size_continuous(
    name = "-log10(q value)",
    range = c(1, 7),
    breaks = c(10, 50, 100, 150)
  ) +
  theme(
    panel.grid.major = element_line(size = 0.25),
    axis.text.y = element_text(size = 10),
    axis.text.x = element_text(size = 10, angle = 90, vjust = 0.5, hjust = 1),
    axis.title.x = element_blank(),
    legend.direction = "vertical"
  ) +
  facet_grid(. ~ reporterline, scales = "free")

```

```{r include=FALSE, eval=TRUE}
pdf(
  file.path(fig_dir, "BINDetect_motifs.pdf"),
  width = 14, height = 16
)
gp_dot
dev.off()
```

## TF-gene networks

Parse bound files for all motifs

```{r eval=FALSE}
bound_dt <- rbindlist(lapply("tfs", function(x) {
  message(x)
  mot_dirs <- list.dirs(file.path(bind_dir, x), recursive = FALSE)
  mot_dirs <- grep("ARCH", mot_dirs, value = TRUE)
  mot <- str_remove(basename(mot_dirs), "^_")
  names(mot_dirs) <- mot
  rbindlist(sapply(mot, function(m) {
    message(m)
    fns <- list.files(
      mot_dirs[m],
      pattern = "_overview.txt",
      full.names = TRUE
    )
    fread(fns)
  }, simplify = FALSE, USE.NAMES = TRUE))
}))

# parse per sample
ftp_dt <- rbindlist(sapply(paste0(
  c("Elav", "Ncol", "Fox"), rep(c("_pos", "_neg"), each = 3)
), function(x) {
  
  bnd_cols <- c(
    "TFBS_chr", "TFBS_start", "TFBS_end", "TFBS_strand", "TFBS_name", "TFBS_score",
    "peak_chr", "peak_start", "peak_end", "additional_1", paste0(x, "_bound"), paste0(x, "_score")
  )
  bed_cols <- c(
    "seqnames", "start", "end", "strand", "motif_name", "motif_score",
    "seqnames_peak", "start_peak", "end_peak", "peak", "bound", "footprint_score"
  )
  bc <- paste0(x, "_bound")
  bound_x_dt <- bound_dt[, ..bnd_cols] # [bound_dt[[bc]] == 1]
  setnames(bound_x_dt, bed_cols)
  bound_x_dt[, motif_name := str_remove(motif_name, "^_")]
}, simplify = FALSE, USE.NAMES = TRUE), idcol = "sample")

# add motif-to-gene assignments
ftp_dt[, motif := str_extract(motif_name, "ARCH\\d+")]
ftp_dt <- merge.data.table(
  ftp_dt, dc_tf, by = "motif",
  all.x = TRUE, sort = FALSE, allow.cartesian = TRUE
)

# save
fwrite(
  ftp_dt,
  file.path(bind_dir, "motifs_all.tsv.gz"),
  sep = "\t"
)

# save only bound motifs
ftp_dt <- ftp_dt[bound == 1][, bound := NULL]
fwrite(
  ftp_dt,
  file.path(bind_dir, "motifs_bound.tsv.gz"),
  sep = "\t"
)
```

```{r}
# load motif binding in peaks
bound_dt <- fread(file.path(bind_dir, "motifs_all.tsv.gz"))

# order samples
bound_dt[, sample := factor(sample, levels = c(
  "Elav_pos", "Elav_neg",
  "Fox_pos", "Fox_neg",
  "Ncol_pos", "Ncol_neg"
))]

# add peak to target gene assignment
assign <- fread(file.path(dat_dir, "results", "consensusSeekeR-peaks-gene-assignment.tsv"))
assign <- unique(assign[, .(gene, peak)])
setnames(assign, "gene", "target_gene")
bound_dt <- merge.data.table(
  bound_dt, assign, by = "peak",
  all.x = TRUE, sort = FALSE, allow.cartesian = TRUE
)
bound_dt <- bound_dt[!is.na(target_gene)]
```

Aggregate peaks and subset targets for expressed genes

```{r}
# parse only motif + gene + target gene + sample info, for pos samples
mo_dt <- bound_dt[order(-footprint_score)][, .SD[1], .(motif, gene, target_gene, sample)][grep("pos", sample)]
mo_dt <- unique(mo_dt[, .(
  motif, motif_name, gene, name, pfam, target_gene, motif_score, footprint_score, bound, sample
)])

# add target gene annotation
target_gene_ann <- copy(gene_ann)
setnames(
  target_gene_ann,
  colnames(target_gene_ann),
  paste0("target_", colnames(target_gene_ann))
)
mo_dt <- merge.data.table(
  mo_dt, target_gene_ann, by = "target_gene",
  all.x = TRUE, sort = FALSE
)
mo_dt[is.na(target_pfam), target_pfam := ""]
mo_dt[is.na(target_name), target_name := ""]

# gene expression tpm
tpm_mt <- read.table(
  file.path("RNASEQ_QUANTIFICATION", "raw_counts_rnaseq.tsv"),
  header = TRUE, row.names = 1
)

# aggregate replicates
smpl <- paste(
  str_extract(colnames(tpm_mt), "Fox|Elav|Ncol"),
  str_to_lower(str_extract(colnames(tpm_mt), "Pos|Neg")),
  sep = "_"
)
smpl_mt <- tapply(colnames(tpm_mt), smpl, function(y) {
  apply(tpm_mt[, y], 1, mean)
}, simplify = FALSE)
smpl_mt <- do.call("cbind", smpl_mt)

# expressed genes
tpm_genes_dt <- rbindlist(apply(smpl_mt, 2, function(x) {
  data.table(expression_tpm = x)[, gene := names(x)]
}, simplify = FALSE), idcol = "sample")
mo_dt <- merge.data.table(
  mo_dt, tpm_genes_dt,
  by = c("gene", "sample"),
  all.x = TRUE, sort = FALSE
)
mo_dt[, expressed := FALSE][expression_tpm > 100, expressed := TRUE]
unique(
  mo_dt[, .(sample, gene, expressed)]
)[, .N, .(sample, expressed)][order(sample, expressed)]

# expressed target genes
tmp_tgenes_dt <- copy(tpm_genes_dt)
setnames(tmp_tgenes_dt, c("gene", "expression_tpm"), c("target_gene", "target_expression_tpm"))
mo_dt <- merge.data.table(
  mo_dt, tmp_tgenes_dt,
  by = c("target_gene", "sample"),
  all.x = TRUE, sort = FALSE
)
mo_dt[, target_expressed := FALSE][target_expression_tpm > 100, target_expressed := TRUE]
unique(
  mo_dt[, .(sample, target_gene, target_expressed)]
)[, .N, .(sample, target_expressed)][order(sample, target_expressed)]

# gene expression lfc
lfc_mt <- read.table(
  file.path("RNASEQ_QUANTIFICATION", "results", "log2fc_expression.tsv"),
  sep = "\t",
  header = TRUE
)
lfc_mt <- lfc_mt[, grep("vs_neg", colnames(lfc_mt))]
lfc_dt <- melt.data.table(
  as.data.table(lfc_mt, keep.rownames = "gene"),
  id.vars = "gene",
  variable.name = "sample",
  value.name = "expression_lfc"
)
lfc_dt[, sample := str_replace_all(sample, "_vs_neg", "_pos")]
mo_dt <- merge.data.table(
  mo_dt, lfc_dt, by = c("sample", "gene"),
  all.x = TRUE, sort = FALSE
)

# target expression lfc
lfc_tg <- copy(lfc_dt)
setnames(lfc_tg, c("gene", "expression_lfc"), c("target_gene", "target_expression_lfc"))
mo_dt <- merge.data.table(
  mo_dt, lfc_tg, by = c("sample", "target_gene"),
  all.x = TRUE, sort = FALSE
)

# save
mo_dt <- mo_dt[!is.na(target_gene)]
mo_dt[, bound := as.logical(bound)]
setcolorder(mo_dt, c(
  "sample", "gene", "target_gene", "name", "pfam", "target_name", "target_pfam",
  "expression_tpm", "target_expression_tpm",
  "expression_lfc", "target_expression_lfc",
  "expressed", "target_expressed",
  "motif", "motif_name", "motif_score", "bound", "footprint_score"
))
fwrite(
  mo_dt,
  file.path(res_dir, "motifs_genes_targets_long.tsv.gz"),
  sep = "\t"
)
```

How many target genes for each TF?

```{r fig.width=4, fig.height=6}
hits_dt <- unique(mo_dt[expressed == TRUE][bound == TRUE][, .(sample, motif, gene, target_gene)])
hits_dt <- hits_dt[, .N, .(motif, sample)]

hits_gp <- ggplot(hits_dt, aes(sample, N, fill = sample)) +
  geom_boxplot() +
  scale_y_continuous(trans = "log10") +
  scale_fill_manual(values = line_cond_cols) +
  labs(y = "number of target genes per TF") +
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
    legend.position = "none",
    panel.grid.major.y = element_line(linewidth = 0.5),
    panel.grid.minor.y = element_line(linewidth = 0.2)
  )
hits_gp
```

```{r include=FALSE, eval=TRUE}
pdf(
  file.path(fig_dir, "BINDetect_motif_target_hits.pdf"),
  width = 5, height = 7
)
hits_gp
dev.off()
```

Find different peaks for same genes in different reporter lines

```{r}
bound_pos_dt <- bound_dt[grepl("pos",sample)]#[bound==1]
bound_pos_dt[, npeaks := length(unique(.SD$peak)), target_gene]

# subset for expressed genes
bound_pos_dt <- merge.data.table(bound_pos_dt, tpm_genes_dt, by = c("sample", "gene"))
bound_pos_dt <- merge.data.table(bound_pos_dt, tmp_tgenes_dt, by = c("sample", "target_gene"))
bound_pos_dt <- bound_pos_dt[expression_tpm > 1000]

# any bound TF per peak
bound_pos_dt <- bound_pos_dt[, bound := any(bound==1), .(peak, target_gene, sample)]
bound_pos_dt[, c("gene","name","pfam", "expression_tpm"):= NULL]
bound_pos_dt <- unique(bound_pos_dt)

# # # # # # # # # # 
# peaks approach  #
# # # # # # # # # #

# genes only expressed in fox
genes_fox <- unique(bound_pos_dt[sample=="Fox_pos" & target_expression_tpm > 1000]$target_gene)
genes_notncol <- unique(bound_pos_dt[sample=="Ncol_pos" & target_expression_tpm < 1000]$target_gene)
genes_notelav <- unique(bound_pos_dt[sample=="Elav_pos" & target_expression_tpm < 1000]$target_gene)
genes_not <- intersect(genes_notncol, genes_notelav)
length(genes_not)
# 10524
genes_cand <- intersect(genes_not, genes_fox)
length(genes_cand)
# 612

# peaks that are bound only in fox
pks_notncol=unique(bound_pos_dt[(sample=="Ncol_pos" & bound==0)]$peak)
pks_notelav=unique(bound_pos_dt[(sample=="Elav_pos" & bound==0)]$peak)
pks_not=intersect(pks_notelav, pks_notncol)
length(pks_not)
# 31335
pks_cand=intersect(pks_not, pks_fox)
length(pks_cand)
# 1173

# get genes associated to candidate peaks
cands_dt <- unique(bound_pos_dt[target_gene %in% genes_cand])
cands_dt <- unique(cands_dt[peak %in% pks_cand][sample=="Fox_pos"][order(-footprint_score)][,.(target_gene, peak, footprint_score)])

# # # # # # # # # # 
# genes approach  #
# # # # # # # # # #

# in how many lines is each peak associated to gene
pks_cnt_dt <- unique(bound_pos_dt[,.(target_gene,peak,sample)])[,.N,.(target_gene,peak)]

# in how many lines are all peaks associated to each gene
gns_cnt_dt <- pks_cnt_dt[,.(N=length(unique(.SD$N))),target_gene]

# get candidate genes that have different peaks in three reporter lines
cands <- bound_pos_dt[
  target_gene %in% gns_cnt_dt[N==3]$target_gene &
    peak %in% pks_cnt_dt[target_gene %in% gns_cnt_dt[N==3]$target_gene]$peak
]
```